// generated by net_code_gen.py based on net_format.txt

#if !_COMPILER
#include "snapshot.h"
#include "client.h"
#include "state.h"
#include "engine/net/player.h"
#include "game/entity/character_monster.h"
#include "game/entity/character_player.h"
#include "game/entity/pickups/pickup_health.h"
#include "game/entity/pickups/pickup_weapon.h"
#include "game/entity/pickups/pickup_weapon.h"
#include "game/entity/pickups/pickup_weapon.h"
#include "game/entity/pickups/pickup_weapon.h"
#include "game/entity/pickups/powerups/pickup_powerup_brain.h"
#include "game/entity/pickups/powerups/pickup_powerup_invis.h"
#include "game/entity/powerups/powerup_brain.h"
#include "game/entity/powerups/powerup_invis.h"
#include "game/entity/projectiles/proj_atom.h"
#include "game/entity/projectiles/proj_blast.h"
#include "game/entity/projectiles/proj_cannon.h"
#include "game/entity/projectiles/proj_rocket.h"
#include "game/entity/projectiles/proj_shotgun.h"
#include "game/entity/projectiles/proj_shotgun_boulder.h"
#include "game/entity/weapons/wep_blast.h"
#include "game/entity/weapons/wep_cannon.h"
#include "game/entity/weapons/wep_rocket.h"
#include "game/entity/weapons/wep_shotgun.h"
#include "game/entity/weapons/wep_zapper.h"

THashMap<std::type_index, u8> ClassIDs =
{
	{ typeid(KNetPlayer), 223 },
	{ typeid(KEntity_Character_Monster), 251 },
	{ typeid(KEntity_Character_Player), 128 },
	{ typeid(KEntity_Pickup_Health), 72 },
	{ typeid(KEntity_Pickup_Weapon_Rocket), 35 },
	{ typeid(KEntity_Pickup_Weapon_Cannon), 24 },
	{ typeid(KEntity_Pickup_Weapon_Shotgun), 163 },
	{ typeid(KEntity_Pickup_Weapon_Blast), 177 },
	{ typeid(KEntity_Pickup_Powerup_Brain), 47 },
	{ typeid(KEntity_Pickup_Powerup_Invis), 76 },
	{ typeid(KEntity_Powerup_Brain), 100 },
	{ typeid(KEntity_Powerup_Invis), 129 },
	{ typeid(KEntity_Projectile_Atom), 40 },
	{ typeid(KEntity_Projectile_Blast), 141 },
	{ typeid(KEntity_Projectile_Cannon), 244 },
	{ typeid(KEntity_Projectile_Rocket), 255 },
	{ typeid(KEntity_Projectile_ShotgunShard), 113 },
	{ typeid(KEntity_Projectile_ShotgunBoulder), 77 },
	{ typeid(KEntity_Weapon_Blast), 230 },
	{ typeid(KEntity_Weapon_Cannon), 78 },
	{ typeid(KEntity_Weapon_Rocket), 88 },
	{ typeid(KEntity_Weapon_Shotgun), 216 },
	{ typeid(KEntity_Weapon_Zapper), 98 },
	
};

u8 KSnapshot::GetPlayerClassID()
{
	return 223;
}

struct KPendingOnRep
{
	KSnapshottable* Object = nullptr;
	u8 Index;
};

TVector<KPendingOnRep> PendingOnReps;
TVector<KPendingOnRep> DestroyPendingOnReps;

u8 KSnapshot::LookUpClassID(std::type_index ind)
{
	return ClassIDs[ind];
}

KString KSnapshot::NameFromClassID(u8 id)
{
	switch (id)
	{
		case 223: return "KNetPlayer";
		case 251: return "KEntity_Character_Monster";
		case 128: return "KEntity_Character_Player";
		case 72: return "KEntity_Pickup_Health";
		case 35: return "KEntity_Pickup_Weapon_Rocket";
		case 24: return "KEntity_Pickup_Weapon_Cannon";
		case 163: return "KEntity_Pickup_Weapon_Shotgun";
		case 177: return "KEntity_Pickup_Weapon_Blast";
		case 47: return "KEntity_Pickup_Powerup_Brain";
		case 76: return "KEntity_Pickup_Powerup_Invis";
		case 100: return "KEntity_Powerup_Brain";
		case 129: return "KEntity_Powerup_Invis";
		case 40: return "KEntity_Projectile_Atom";
		case 141: return "KEntity_Projectile_Blast";
		case 244: return "KEntity_Projectile_Cannon";
		case 255: return "KEntity_Projectile_Rocket";
		case 113: return "KEntity_Projectile_ShotgunShard";
		case 77: return "KEntity_Projectile_ShotgunBoulder";
		case 230: return "KEntity_Weapon_Blast";
		case 78: return "KEntity_Weapon_Cannon";
		case 88: return "KEntity_Weapon_Rocket";
		case 216: return "KEntity_Weapon_Shotgun";
		case 98: return "KEntity_Weapon_Zapper";
		
	}
	return "";
}

struct KSnapshot_KNetPlayer : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KReppedPlayerName ReppedName;
	u32 LastInputFrame = 0;
	u32 LastAckedFrame = 0;
	u8 TotalFrameDrops = 0;
	i32 Score = 0;
	i32 Frags = 0;
	i32 Deaths = 0;
	i32 Damage = 0;
	u8 PackedPing = 0;
	bool bUpdateScoreboard = false;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KNetPlayer* object, const u8* data);
	static void ApplyOnRep(KNetPlayer* obj, u8 index);
};

struct KSnapshot_KEntity_Character_Monster : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u16 KillStreak = 0;
	KNetVec3 ReplayPosition;
	u8 KillingPlayerIndex = NULL_PLAYER;
	GVec3 PositionForOwner;
	i16 Health = 100;
	u16 ReppedPitch;
	u16 ReppedYaw;
	u16 ReplayPitch;
	u16 ReplayYaw;
	u16 SpawnYaw;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	KNetVec3 ReppedNetPos;
	f32 DamageMultiplier = 1;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Character_Monster* object, const u8* data);
	static void ApplyOnRep(KEntity_Character_Monster* obj, u8 index);
};

struct KSnapshot_KEntity_Character_Player : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	f32 DamageMultiplier = 1;
	u16 KillStreak = 0;
	KNetVec3 ReplayPosition;
	u8 KillingPlayerIndex = NULL_PLAYER;
	GVec3 PositionForOwner;
	i16 Health = 100;
	u16 ReppedPitch;
	u16 ReppedYaw;
	u16 ReplayPitch;
	u16 ReplayYaw;
	u16 SpawnYaw;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	KNetVec3 ReppedNetPos;
	u8 ReplicatedWeaponIndex = EWeaponID::Shotgun;
	KNetVec3 DeathVelocity;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Character_Player* object, const u8* data);
	static void ApplyOnRep(KEntity_Character_Player* obj, u8 index);
};

struct KSnapshot_KEntity_Pickup_Health : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 LastPickupEntID = 0;
	KNetVec3 ReppedNetPos;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	u8 ReppedFlags = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Pickup_Health* object, const u8* data);
	static void ApplyOnRep(KEntity_Pickup_Health* obj, u8 index);
};

struct KSnapshot_KEntity_Pickup_Weapon_Rocket : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u8 PushFramesRemaining = 0;
	GVec3 VelocityForOwner;
	u8 CrouchDepth = 0;
	EMoveState MovementState;
	KNetVec3 ReppedNetPos;
	u32 LastPickupEntID = 0;
	u8 ReppedFlags = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Pickup_Weapon_Rocket* object, const u8* data);
	static void ApplyOnRep(KEntity_Pickup_Weapon_Rocket* obj, u8 index);
};

struct KSnapshot_KEntity_Pickup_Weapon_Cannon : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u8 PushFramesRemaining = 0;
	GVec3 VelocityForOwner;
	u8 CrouchDepth = 0;
	EMoveState MovementState;
	KNetVec3 ReppedNetPos;
	u32 LastPickupEntID = 0;
	u8 ReppedFlags = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Pickup_Weapon_Cannon* object, const u8* data);
	static void ApplyOnRep(KEntity_Pickup_Weapon_Cannon* obj, u8 index);
};

struct KSnapshot_KEntity_Pickup_Weapon_Shotgun : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u8 PushFramesRemaining = 0;
	GVec3 VelocityForOwner;
	u8 CrouchDepth = 0;
	EMoveState MovementState;
	KNetVec3 ReppedNetPos;
	u32 LastPickupEntID = 0;
	u8 ReppedFlags = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Pickup_Weapon_Shotgun* object, const u8* data);
	static void ApplyOnRep(KEntity_Pickup_Weapon_Shotgun* obj, u8 index);
};

struct KSnapshot_KEntity_Pickup_Weapon_Blast : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u8 PushFramesRemaining = 0;
	GVec3 VelocityForOwner;
	u8 CrouchDepth = 0;
	EMoveState MovementState;
	KNetVec3 ReppedNetPos;
	u32 LastPickupEntID = 0;
	u8 ReppedFlags = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Pickup_Weapon_Blast* object, const u8* data);
	static void ApplyOnRep(KEntity_Pickup_Weapon_Blast* obj, u8 index);
};

struct KSnapshot_KEntity_Pickup_Powerup_Brain : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u8 ReppedFlags = 0;
	u8 PushFramesRemaining = 0;
	GVec3 VelocityForOwner;
	u8 CrouchDepth = 0;
	EMoveState MovementState;
	KNetVec3 ReppedNetPos;
	u32 LastPickupEntID = 0;
	u32 DropDeathFrame = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Pickup_Powerup_Brain* object, const u8* data);
	static void ApplyOnRep(KEntity_Pickup_Powerup_Brain* obj, u8 index);
};

struct KSnapshot_KEntity_Pickup_Powerup_Invis : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u8 ReppedFlags = 0;
	u8 PushFramesRemaining = 0;
	GVec3 VelocityForOwner;
	u8 CrouchDepth = 0;
	EMoveState MovementState;
	KNetVec3 ReppedNetPos;
	u32 LastPickupEntID = 0;
	u32 DropDeathFrame = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Pickup_Powerup_Invis* object, const u8* data);
	static void ApplyOnRep(KEntity_Pickup_Powerup_Invis* obj, u8 index);
};

struct KSnapshot_KEntity_Powerup_Brain : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 EndFrame;
	u32 CarryingEntID = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Powerup_Brain* object, const u8* data);
	static void ApplyOnRep(KEntity_Powerup_Brain* obj, u8 index);
};

struct KSnapshot_KEntity_Powerup_Invis : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 EndFrame;
	u32 CarryingEntID = 0;
	bool bIsInvisible = false;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Powerup_Invis* object, const u8* data);
	static void ApplyOnRep(KEntity_Powerup_Invis* obj, u8 index);
};

struct KSnapshot_KEntity_Projectile_Atom : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KNetVec3 ReplicatedVelocity;
	KNetVec3 ReplicatedPosition;
	i16 Health = 100;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	bool bPrimaryFire = false;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Projectile_Atom* object, const u8* data);
	static void ApplyOnRep(KEntity_Projectile_Atom* obj, u8 index);
};

struct KSnapshot_KEntity_Projectile_Blast : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KNetVec3 ReplicatedVelocity;
	KNetVec3 ReplicatedPosition;
	i16 Health = 100;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	bool bPrimaryFire = false;
	KNetVec3 DestroyPosition;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Projectile_Blast* object, const u8* data);
	static void ApplyOnRep(KEntity_Projectile_Blast* obj, u8 index);
};

struct KSnapshot_KEntity_Projectile_Cannon : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KNetVec3 ReplicatedVelocity;
	KNetVec3 ReplicatedPosition;
	i16 Health = 100;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	bool bPrimaryFire = false;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Projectile_Cannon* object, const u8* data);
	static void ApplyOnRep(KEntity_Projectile_Cannon* obj, u8 index);
};

struct KSnapshot_KEntity_Projectile_Rocket : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KNetVec3 ReplicatedVelocity;
	KNetVec3 ReplicatedPosition;
	i16 Health = 100;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	bool bPrimaryFire = false;
	KNetVec3 DestroyPosition;
	KNetVec3 DestroyNormal;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Projectile_Rocket* object, const u8* data);
	static void ApplyOnRep(KEntity_Projectile_Rocket* obj, u8 index);
};

struct KSnapshot_KEntity_Projectile_ShotgunShard : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KNetVec3 ReplicatedVelocity;
	KNetVec3 ReplicatedPosition;
	i16 Health = 100;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	bool bPrimaryFire = false;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Projectile_ShotgunShard* object, const u8* data);
	static void ApplyOnRep(KEntity_Projectile_ShotgunShard* obj, u8 index);
};

struct KSnapshot_KEntity_Projectile_ShotgunBoulder : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KNetVec3 ReplicatedVelocity;
	KNetVec3 ReplicatedPosition;
	i16 Health = 100;
	EMoveState MovementState;
	u8 CrouchDepth = 0;
	GVec3 VelocityForOwner;
	u8 PushFramesRemaining = 0;
	bool bPrimaryFire = false;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Projectile_ShotgunBoulder* object, const u8* data);
	static void ApplyOnRep(KEntity_Projectile_ShotgunBoulder* obj, u8 index);
};

struct KSnapshot_KEntity_Weapon_Blast : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u16 AmmoCount = 0;
	u32 OwningEntityID = 0;
	bool bFrenzySound = false;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Weapon_Blast* object, const u8* data);
	static void ApplyOnRep(KEntity_Weapon_Blast* obj, u8 index);
};

struct KSnapshot_KEntity_Weapon_Cannon : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u16 AmmoCount = 0;
	u32 OwningEntityID = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Weapon_Cannon* object, const u8* data);
	static void ApplyOnRep(KEntity_Weapon_Cannon* obj, u8 index);
};

struct KSnapshot_KEntity_Weapon_Rocket : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u16 AmmoCount = 0;
	u32 OwningEntityID = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Weapon_Rocket* object, const u8* data);
	static void ApplyOnRep(KEntity_Weapon_Rocket* obj, u8 index);
};

struct KSnapshot_KEntity_Weapon_Shotgun : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u16 AmmoCount = 0;
	u32 OwningEntityID = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Weapon_Shotgun* object, const u8* data);
	static void ApplyOnRep(KEntity_Weapon_Shotgun* obj, u8 index);
};

struct KSnapshot_KEntity_Weapon_Zapper : public KSnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u16 AmmoCount = 0;
	u32 OwningEntityID = 0;
	
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, KEntity_Weapon_Zapper* object, const u8* data);
	static void ApplyOnRep(KEntity_Weapon_Zapper* obj, u8 index);
};

#pragma pack(push, 1)
struct KDestroySnapshot_KNetPlayer : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KNetPlayer* obj);
	static void ApplyOnRep(KNetPlayer* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Character_Monster : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u16 KillStreak = 0;
	u8 KillingPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Character_Monster* obj);
	static void ApplyOnRep(KEntity_Character_Monster* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Character_Player : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u16 KillStreak = 0;
	u8 KillingPlayerIndex = NULL_PLAYER;
	KNetVec3 DeathVelocity;
	
	
	void ApplyDestroyToObject(KEntity_Character_Player* obj);
	static void ApplyOnRep(KEntity_Character_Player* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Pickup_Health : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 LastPickupEntID = 0;
	
	
	void ApplyDestroyToObject(KEntity_Pickup_Health* obj);
	static void ApplyOnRep(KEntity_Pickup_Health* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Pickup_Weapon_Rocket : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 LastPickupEntID = 0;
	
	
	void ApplyDestroyToObject(KEntity_Pickup_Weapon_Rocket* obj);
	static void ApplyOnRep(KEntity_Pickup_Weapon_Rocket* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Pickup_Weapon_Cannon : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 LastPickupEntID = 0;
	
	
	void ApplyDestroyToObject(KEntity_Pickup_Weapon_Cannon* obj);
	static void ApplyOnRep(KEntity_Pickup_Weapon_Cannon* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 LastPickupEntID = 0;
	
	
	void ApplyDestroyToObject(KEntity_Pickup_Weapon_Shotgun* obj);
	static void ApplyOnRep(KEntity_Pickup_Weapon_Shotgun* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Pickup_Weapon_Blast : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 LastPickupEntID = 0;
	
	
	void ApplyDestroyToObject(KEntity_Pickup_Weapon_Blast* obj);
	static void ApplyOnRep(KEntity_Pickup_Weapon_Blast* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Pickup_Powerup_Brain : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 LastPickupEntID = 0;
	
	
	void ApplyDestroyToObject(KEntity_Pickup_Powerup_Brain* obj);
	static void ApplyOnRep(KEntity_Pickup_Powerup_Brain* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Pickup_Powerup_Invis : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	u32 LastPickupEntID = 0;
	
	
	void ApplyDestroyToObject(KEntity_Pickup_Powerup_Invis* obj);
	static void ApplyOnRep(KEntity_Pickup_Powerup_Invis* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Powerup_Brain : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Powerup_Brain* obj);
	static void ApplyOnRep(KEntity_Powerup_Brain* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Powerup_Invis : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Powerup_Invis* obj);
	static void ApplyOnRep(KEntity_Powerup_Invis* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Projectile_Atom : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Projectile_Atom* obj);
	static void ApplyOnRep(KEntity_Projectile_Atom* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Projectile_Blast : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KNetVec3 DestroyPosition;
	
	
	void ApplyDestroyToObject(KEntity_Projectile_Blast* obj);
	static void ApplyOnRep(KEntity_Projectile_Blast* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Projectile_Cannon : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Projectile_Cannon* obj);
	static void ApplyOnRep(KEntity_Projectile_Cannon* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Projectile_Rocket : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	KNetVec3 DestroyPosition;
	KNetVec3 DestroyNormal;
	
	
	void ApplyDestroyToObject(KEntity_Projectile_Rocket* obj);
	static void ApplyOnRep(KEntity_Projectile_Rocket* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Projectile_ShotgunShard : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Projectile_ShotgunShard* obj);
	static void ApplyOnRep(KEntity_Projectile_ShotgunShard* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Projectile_ShotgunBoulder : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Projectile_ShotgunBoulder* obj);
	static void ApplyOnRep(KEntity_Projectile_ShotgunBoulder* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Weapon_Blast : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Weapon_Blast* obj);
	static void ApplyOnRep(KEntity_Weapon_Blast* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Weapon_Cannon : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Weapon_Cannon* obj);
	static void ApplyOnRep(KEntity_Weapon_Cannon* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Weapon_Rocket : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Weapon_Rocket* obj);
	static void ApplyOnRep(KEntity_Weapon_Rocket* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Weapon_Shotgun : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Weapon_Shotgun* obj);
	static void ApplyOnRep(KEntity_Weapon_Shotgun* obj, u8 index);
};
#pragma pack(pop)

#pragma pack(push, 1)
struct KDestroySnapshot_KEntity_Weapon_Zapper : public KDestroySnapshot
{
	u8 OwningPlayerIndex = NULL_PLAYER;
	
	
	void ApplyDestroyToObject(KEntity_Weapon_Zapper* obj);
	static void ApplyOnRep(KEntity_Weapon_Zapper* obj, u8 index);
};
#pragma pack(pop)

UPtr<KDestroySnapshot> KDestroySnapshot::FillDestroy(KSnapshottable* obj)
{
	switch (obj->ClassID)
	{
		case 223:
		{
			KNetPlayer* casted = (KNetPlayer*)obj;
			UPtr<KDestroySnapshot_KNetPlayer> snap = std::make_unique<KDestroySnapshot_KNetPlayer>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 251:
		{
			KEntity_Character_Monster* casted = (KEntity_Character_Monster*)obj;
			UPtr<KDestroySnapshot_KEntity_Character_Monster> snap = std::make_unique<KDestroySnapshot_KEntity_Character_Monster>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->KillStreak;
				u8 size = sizeof(u16);
				u8* objAddr = (u8*)&casted->KillStreak;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->KillingPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->KillingPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 128:
		{
			KEntity_Character_Player* casted = (KEntity_Character_Player*)obj;
			UPtr<KDestroySnapshot_KEntity_Character_Player> snap = std::make_unique<KDestroySnapshot_KEntity_Character_Player>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->KillStreak;
				u8 size = sizeof(u16);
				u8* objAddr = (u8*)&casted->KillStreak;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->KillingPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->KillingPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->DeathVelocity;
				u8 size = sizeof(KNetVec3);
				KNetVec3  val;
		casted->GetTransient_DeathVelocity(val);
		memcpy(snapAddr, &val, size);	
			}
			return snap;
		}
		case 72:
		{
			KEntity_Pickup_Health* casted = (KEntity_Pickup_Health*)obj;
			UPtr<KDestroySnapshot_KEntity_Pickup_Health> snap = std::make_unique<KDestroySnapshot_KEntity_Pickup_Health>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->LastPickupEntID;
				u8 size = sizeof(u32);
				u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 35:
		{
			KEntity_Pickup_Weapon_Rocket* casted = (KEntity_Pickup_Weapon_Rocket*)obj;
			UPtr<KDestroySnapshot_KEntity_Pickup_Weapon_Rocket> snap = std::make_unique<KDestroySnapshot_KEntity_Pickup_Weapon_Rocket>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->LastPickupEntID;
				u8 size = sizeof(u32);
				u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 24:
		{
			KEntity_Pickup_Weapon_Cannon* casted = (KEntity_Pickup_Weapon_Cannon*)obj;
			UPtr<KDestroySnapshot_KEntity_Pickup_Weapon_Cannon> snap = std::make_unique<KDestroySnapshot_KEntity_Pickup_Weapon_Cannon>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->LastPickupEntID;
				u8 size = sizeof(u32);
				u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 163:
		{
			KEntity_Pickup_Weapon_Shotgun* casted = (KEntity_Pickup_Weapon_Shotgun*)obj;
			UPtr<KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun> snap = std::make_unique<KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->LastPickupEntID;
				u8 size = sizeof(u32);
				u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 177:
		{
			KEntity_Pickup_Weapon_Blast* casted = (KEntity_Pickup_Weapon_Blast*)obj;
			UPtr<KDestroySnapshot_KEntity_Pickup_Weapon_Blast> snap = std::make_unique<KDestroySnapshot_KEntity_Pickup_Weapon_Blast>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->LastPickupEntID;
				u8 size = sizeof(u32);
				u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 47:
		{
			KEntity_Pickup_Powerup_Brain* casted = (KEntity_Pickup_Powerup_Brain*)obj;
			UPtr<KDestroySnapshot_KEntity_Pickup_Powerup_Brain> snap = std::make_unique<KDestroySnapshot_KEntity_Pickup_Powerup_Brain>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->LastPickupEntID;
				u8 size = sizeof(u32);
				u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 76:
		{
			KEntity_Pickup_Powerup_Invis* casted = (KEntity_Pickup_Powerup_Invis*)obj;
			UPtr<KDestroySnapshot_KEntity_Pickup_Powerup_Invis> snap = std::make_unique<KDestroySnapshot_KEntity_Pickup_Powerup_Invis>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->LastPickupEntID;
				u8 size = sizeof(u32);
				u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 100:
		{
			KEntity_Powerup_Brain* casted = (KEntity_Powerup_Brain*)obj;
			UPtr<KDestroySnapshot_KEntity_Powerup_Brain> snap = std::make_unique<KDestroySnapshot_KEntity_Powerup_Brain>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 129:
		{
			KEntity_Powerup_Invis* casted = (KEntity_Powerup_Invis*)obj;
			UPtr<KDestroySnapshot_KEntity_Powerup_Invis> snap = std::make_unique<KDestroySnapshot_KEntity_Powerup_Invis>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 40:
		{
			KEntity_Projectile_Atom* casted = (KEntity_Projectile_Atom*)obj;
			UPtr<KDestroySnapshot_KEntity_Projectile_Atom> snap = std::make_unique<KDestroySnapshot_KEntity_Projectile_Atom>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 141:
		{
			KEntity_Projectile_Blast* casted = (KEntity_Projectile_Blast*)obj;
			UPtr<KDestroySnapshot_KEntity_Projectile_Blast> snap = std::make_unique<KDestroySnapshot_KEntity_Projectile_Blast>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->DestroyPosition;
				u8 size = sizeof(KNetVec3);
				u8* objAddr = (u8*)&casted->DestroyPosition;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 244:
		{
			KEntity_Projectile_Cannon* casted = (KEntity_Projectile_Cannon*)obj;
			UPtr<KDestroySnapshot_KEntity_Projectile_Cannon> snap = std::make_unique<KDestroySnapshot_KEntity_Projectile_Cannon>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 255:
		{
			KEntity_Projectile_Rocket* casted = (KEntity_Projectile_Rocket*)obj;
			UPtr<KDestroySnapshot_KEntity_Projectile_Rocket> snap = std::make_unique<KDestroySnapshot_KEntity_Projectile_Rocket>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->DestroyPosition;
				u8 size = sizeof(KNetVec3);
				u8* objAddr = (u8*)&casted->DestroyPosition;
				memcpy(snapAddr, objAddr, size);	
			}{
				u8* snapAddr = (u8*)&snap->DestroyNormal;
				u8 size = sizeof(KNetVec3);
				u8* objAddr = (u8*)&casted->DestroyNormal;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 113:
		{
			KEntity_Projectile_ShotgunShard* casted = (KEntity_Projectile_ShotgunShard*)obj;
			UPtr<KDestroySnapshot_KEntity_Projectile_ShotgunShard> snap = std::make_unique<KDestroySnapshot_KEntity_Projectile_ShotgunShard>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 77:
		{
			KEntity_Projectile_ShotgunBoulder* casted = (KEntity_Projectile_ShotgunBoulder*)obj;
			UPtr<KDestroySnapshot_KEntity_Projectile_ShotgunBoulder> snap = std::make_unique<KDestroySnapshot_KEntity_Projectile_ShotgunBoulder>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 230:
		{
			KEntity_Weapon_Blast* casted = (KEntity_Weapon_Blast*)obj;
			UPtr<KDestroySnapshot_KEntity_Weapon_Blast> snap = std::make_unique<KDestroySnapshot_KEntity_Weapon_Blast>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 78:
		{
			KEntity_Weapon_Cannon* casted = (KEntity_Weapon_Cannon*)obj;
			UPtr<KDestroySnapshot_KEntity_Weapon_Cannon> snap = std::make_unique<KDestroySnapshot_KEntity_Weapon_Cannon>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 88:
		{
			KEntity_Weapon_Rocket* casted = (KEntity_Weapon_Rocket*)obj;
			UPtr<KDestroySnapshot_KEntity_Weapon_Rocket> snap = std::make_unique<KDestroySnapshot_KEntity_Weapon_Rocket>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 216:
		{
			KEntity_Weapon_Shotgun* casted = (KEntity_Weapon_Shotgun*)obj;
			UPtr<KDestroySnapshot_KEntity_Weapon_Shotgun> snap = std::make_unique<KDestroySnapshot_KEntity_Weapon_Shotgun>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		case 98:
		{
			KEntity_Weapon_Zapper* casted = (KEntity_Weapon_Zapper*)obj;
			UPtr<KDestroySnapshot_KEntity_Weapon_Zapper> snap = std::make_unique<KDestroySnapshot_KEntity_Weapon_Zapper>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			{
				u8* snapAddr = (u8*)&snap->OwningPlayerIndex;
				u8 size = sizeof(u8);
				u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);	
			}
			return snap;
		}
		
	}	
	return nullptr;
}

u32 KDestroySnapshot::GetSize(u8 classID)
{
	switch (classID)
	{
		case (223): return sizeof(KDestroySnapshot_KNetPlayer) - 0;
		case (251): return sizeof(KDestroySnapshot_KEntity_Character_Monster) - 0;
		case (128): return sizeof(KDestroySnapshot_KEntity_Character_Player) - 0;
		case (72): return sizeof(KDestroySnapshot_KEntity_Pickup_Health) - 0;
		case (35): return sizeof(KDestroySnapshot_KEntity_Pickup_Weapon_Rocket) - 0;
		case (24): return sizeof(KDestroySnapshot_KEntity_Pickup_Weapon_Cannon) - 0;
		case (163): return sizeof(KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun) - 0;
		case (177): return sizeof(KDestroySnapshot_KEntity_Pickup_Weapon_Blast) - 0;
		case (47): return sizeof(KDestroySnapshot_KEntity_Pickup_Powerup_Brain) - 0;
		case (76): return sizeof(KDestroySnapshot_KEntity_Pickup_Powerup_Invis) - 0;
		case (100): return sizeof(KDestroySnapshot_KEntity_Powerup_Brain) - 0;
		case (129): return sizeof(KDestroySnapshot_KEntity_Powerup_Invis) - 0;
		case (40): return sizeof(KDestroySnapshot_KEntity_Projectile_Atom) - 0;
		case (141): return sizeof(KDestroySnapshot_KEntity_Projectile_Blast) - 0;
		case (244): return sizeof(KDestroySnapshot_KEntity_Projectile_Cannon) - 0;
		case (255): return sizeof(KDestroySnapshot_KEntity_Projectile_Rocket) - 0;
		case (113): return sizeof(KDestroySnapshot_KEntity_Projectile_ShotgunShard) - 0;
		case (77): return sizeof(KDestroySnapshot_KEntity_Projectile_ShotgunBoulder) - 0;
		case (230): return sizeof(KDestroySnapshot_KEntity_Weapon_Blast) - 0;
		case (78): return sizeof(KDestroySnapshot_KEntity_Weapon_Cannon) - 0;
		case (88): return sizeof(KDestroySnapshot_KEntity_Weapon_Rocket) - 0;
		case (216): return sizeof(KDestroySnapshot_KEntity_Weapon_Shotgun) - 0;
		case (98): return sizeof(KDestroySnapshot_KEntity_Weapon_Zapper) - 0;
		
	}

	return 0;
}

void KDestroySnapshot::Apply(KSnapshottable* obj, u8* destroyData)
{
	switch (obj->ClassID)
	{
		case 223:
		{
			KDestroySnapshot_KNetPlayer* ptr = (KDestroySnapshot_KNetPlayer*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KNetPlayer*>(obj));
			break;
		}
		case 251:
		{
			KDestroySnapshot_KEntity_Character_Monster* ptr = (KDestroySnapshot_KEntity_Character_Monster*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Character_Monster*>(obj));
			break;
		}
		case 128:
		{
			KDestroySnapshot_KEntity_Character_Player* ptr = (KDestroySnapshot_KEntity_Character_Player*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Character_Player*>(obj));
			break;
		}
		case 72:
		{
			KDestroySnapshot_KEntity_Pickup_Health* ptr = (KDestroySnapshot_KEntity_Pickup_Health*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Pickup_Health*>(obj));
			break;
		}
		case 35:
		{
			KDestroySnapshot_KEntity_Pickup_Weapon_Rocket* ptr = (KDestroySnapshot_KEntity_Pickup_Weapon_Rocket*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Pickup_Weapon_Rocket*>(obj));
			break;
		}
		case 24:
		{
			KDestroySnapshot_KEntity_Pickup_Weapon_Cannon* ptr = (KDestroySnapshot_KEntity_Pickup_Weapon_Cannon*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Pickup_Weapon_Cannon*>(obj));
			break;
		}
		case 163:
		{
			KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun* ptr = (KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Pickup_Weapon_Shotgun*>(obj));
			break;
		}
		case 177:
		{
			KDestroySnapshot_KEntity_Pickup_Weapon_Blast* ptr = (KDestroySnapshot_KEntity_Pickup_Weapon_Blast*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Pickup_Weapon_Blast*>(obj));
			break;
		}
		case 47:
		{
			KDestroySnapshot_KEntity_Pickup_Powerup_Brain* ptr = (KDestroySnapshot_KEntity_Pickup_Powerup_Brain*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Pickup_Powerup_Brain*>(obj));
			break;
		}
		case 76:
		{
			KDestroySnapshot_KEntity_Pickup_Powerup_Invis* ptr = (KDestroySnapshot_KEntity_Pickup_Powerup_Invis*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Pickup_Powerup_Invis*>(obj));
			break;
		}
		case 100:
		{
			KDestroySnapshot_KEntity_Powerup_Brain* ptr = (KDestroySnapshot_KEntity_Powerup_Brain*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Powerup_Brain*>(obj));
			break;
		}
		case 129:
		{
			KDestroySnapshot_KEntity_Powerup_Invis* ptr = (KDestroySnapshot_KEntity_Powerup_Invis*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Powerup_Invis*>(obj));
			break;
		}
		case 40:
		{
			KDestroySnapshot_KEntity_Projectile_Atom* ptr = (KDestroySnapshot_KEntity_Projectile_Atom*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Projectile_Atom*>(obj));
			break;
		}
		case 141:
		{
			KDestroySnapshot_KEntity_Projectile_Blast* ptr = (KDestroySnapshot_KEntity_Projectile_Blast*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Projectile_Blast*>(obj));
			break;
		}
		case 244:
		{
			KDestroySnapshot_KEntity_Projectile_Cannon* ptr = (KDestroySnapshot_KEntity_Projectile_Cannon*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Projectile_Cannon*>(obj));
			break;
		}
		case 255:
		{
			KDestroySnapshot_KEntity_Projectile_Rocket* ptr = (KDestroySnapshot_KEntity_Projectile_Rocket*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Projectile_Rocket*>(obj));
			break;
		}
		case 113:
		{
			KDestroySnapshot_KEntity_Projectile_ShotgunShard* ptr = (KDestroySnapshot_KEntity_Projectile_ShotgunShard*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Projectile_ShotgunShard*>(obj));
			break;
		}
		case 77:
		{
			KDestroySnapshot_KEntity_Projectile_ShotgunBoulder* ptr = (KDestroySnapshot_KEntity_Projectile_ShotgunBoulder*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Projectile_ShotgunBoulder*>(obj));
			break;
		}
		case 230:
		{
			KDestroySnapshot_KEntity_Weapon_Blast* ptr = (KDestroySnapshot_KEntity_Weapon_Blast*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Weapon_Blast*>(obj));
			break;
		}
		case 78:
		{
			KDestroySnapshot_KEntity_Weapon_Cannon* ptr = (KDestroySnapshot_KEntity_Weapon_Cannon*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Weapon_Cannon*>(obj));
			break;
		}
		case 88:
		{
			KDestroySnapshot_KEntity_Weapon_Rocket* ptr = (KDestroySnapshot_KEntity_Weapon_Rocket*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Weapon_Rocket*>(obj));
			break;
		}
		case 216:
		{
			KDestroySnapshot_KEntity_Weapon_Shotgun* ptr = (KDestroySnapshot_KEntity_Weapon_Shotgun*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Weapon_Shotgun*>(obj));
			break;
		}
		case 98:
		{
			KDestroySnapshot_KEntity_Weapon_Zapper* ptr = (KDestroySnapshot_KEntity_Weapon_Zapper*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<KEntity_Weapon_Zapper*>(obj));
			break;
		}
		
	}
}


void KDestroySnapshot_KNetPlayer::ApplyDestroyToObject(KNetPlayer* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Character_Monster::ApplyDestroyToObject(KEntity_Character_Monster* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->KillStreak, &KillStreak, sizeof(u16));
		
	}{
		memcpy(&obj->KillingPlayerIndex, &KillingPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Character_Player::ApplyDestroyToObject(KEntity_Character_Player* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->KillStreak, &KillStreak, sizeof(u16));
		
	}{
		memcpy(&obj->KillingPlayerIndex, &KillingPlayerIndex, sizeof(u8));
		
	}{
		obj->SetTransient_DeathVelocity(DeathVelocity);
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Health::ApplyDestroyToObject(KEntity_Pickup_Health* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->LastPickupEntID, &LastPickupEntID, sizeof(u32));
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Weapon_Rocket::ApplyDestroyToObject(KEntity_Pickup_Weapon_Rocket* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->LastPickupEntID, &LastPickupEntID, sizeof(u32));
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Weapon_Cannon::ApplyDestroyToObject(KEntity_Pickup_Weapon_Cannon* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->LastPickupEntID, &LastPickupEntID, sizeof(u32));
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun::ApplyDestroyToObject(KEntity_Pickup_Weapon_Shotgun* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->LastPickupEntID, &LastPickupEntID, sizeof(u32));
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Weapon_Blast::ApplyDestroyToObject(KEntity_Pickup_Weapon_Blast* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->LastPickupEntID, &LastPickupEntID, sizeof(u32));
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Powerup_Brain::ApplyDestroyToObject(KEntity_Pickup_Powerup_Brain* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->LastPickupEntID, &LastPickupEntID, sizeof(u32));
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Powerup_Invis::ApplyDestroyToObject(KEntity_Pickup_Powerup_Invis* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->LastPickupEntID, &LastPickupEntID, sizeof(u32));
		
	}
}

void KDestroySnapshot_KEntity_Powerup_Brain::ApplyDestroyToObject(KEntity_Powerup_Brain* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Powerup_Invis::ApplyDestroyToObject(KEntity_Powerup_Invis* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Projectile_Atom::ApplyDestroyToObject(KEntity_Projectile_Atom* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Projectile_Blast::ApplyDestroyToObject(KEntity_Projectile_Blast* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->DestroyPosition, &DestroyPosition, sizeof(KNetVec3));
		
	}
}

void KDestroySnapshot_KEntity_Projectile_Cannon::ApplyDestroyToObject(KEntity_Projectile_Cannon* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Projectile_Rocket::ApplyDestroyToObject(KEntity_Projectile_Rocket* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}{
		memcpy(&obj->DestroyPosition, &DestroyPosition, sizeof(KNetVec3));
		
	}{
		memcpy(&obj->DestroyNormal, &DestroyNormal, sizeof(KNetVec3));
		
	}
}

void KDestroySnapshot_KEntity_Projectile_ShotgunShard::ApplyDestroyToObject(KEntity_Projectile_ShotgunShard* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Projectile_ShotgunBoulder::ApplyDestroyToObject(KEntity_Projectile_ShotgunBoulder* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Blast::ApplyDestroyToObject(KEntity_Weapon_Blast* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Cannon::ApplyDestroyToObject(KEntity_Weapon_Cannon* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Rocket::ApplyDestroyToObject(KEntity_Weapon_Rocket* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Shotgun::ApplyDestroyToObject(KEntity_Weapon_Shotgun* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Zapper::ApplyDestroyToObject(KEntity_Weapon_Zapper* obj)
{
	{
		memcpy(&obj->OwningPlayerIndex, &OwningPlayerIndex, sizeof(u8));
		
	}
}



THashMap<u32, KSnapshot_KNetPlayer[MAX_SNAPSHOTS]> SnapshotHistory_KNetPlayer;
THashMap<u32, KSnapshot_KEntity_Character_Monster[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Character_Monster;
THashMap<u32, KSnapshot_KEntity_Character_Player[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Character_Player;
THashMap<u32, KSnapshot_KEntity_Pickup_Health[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Pickup_Health;
THashMap<u32, KSnapshot_KEntity_Pickup_Weapon_Rocket[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Pickup_Weapon_Rocket;
THashMap<u32, KSnapshot_KEntity_Pickup_Weapon_Cannon[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Pickup_Weapon_Cannon;
THashMap<u32, KSnapshot_KEntity_Pickup_Weapon_Shotgun[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Pickup_Weapon_Shotgun;
THashMap<u32, KSnapshot_KEntity_Pickup_Weapon_Blast[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Pickup_Weapon_Blast;
THashMap<u32, KSnapshot_KEntity_Pickup_Powerup_Brain[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Pickup_Powerup_Brain;
THashMap<u32, KSnapshot_KEntity_Pickup_Powerup_Invis[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Pickup_Powerup_Invis;
THashMap<u32, KSnapshot_KEntity_Powerup_Brain[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Powerup_Brain;
THashMap<u32, KSnapshot_KEntity_Powerup_Invis[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Powerup_Invis;
THashMap<u32, KSnapshot_KEntity_Projectile_Atom[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Projectile_Atom;
THashMap<u32, KSnapshot_KEntity_Projectile_Blast[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Projectile_Blast;
THashMap<u32, KSnapshot_KEntity_Projectile_Cannon[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Projectile_Cannon;
THashMap<u32, KSnapshot_KEntity_Projectile_Rocket[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Projectile_Rocket;
THashMap<u32, KSnapshot_KEntity_Projectile_ShotgunShard[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Projectile_ShotgunShard;
THashMap<u32, KSnapshot_KEntity_Projectile_ShotgunBoulder[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Projectile_ShotgunBoulder;
THashMap<u32, KSnapshot_KEntity_Weapon_Blast[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Weapon_Blast;
THashMap<u32, KSnapshot_KEntity_Weapon_Cannon[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Weapon_Cannon;
THashMap<u32, KSnapshot_KEntity_Weapon_Rocket[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Weapon_Rocket;
THashMap<u32, KSnapshot_KEntity_Weapon_Shotgun[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Weapon_Shotgun;
THashMap<u32, KSnapshot_KEntity_Weapon_Zapper[MAX_SNAPSHOTS]> SnapshotHistory_KEntity_Weapon_Zapper;


void KSnapshot_KNetPlayer::PackObject(class KSnapshottable* obj)
{
	KNetPlayer* casted = (KNetPlayer*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		KReppedPlayerName  val;
		casted->GetTransient_ReppedName(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastInputFrame;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastAckedFrame;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->TotalFrameDrops;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->Score;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->Frags;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->Deaths;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u8* objAddr = (u8*)&casted->Damage;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(9, snapAddr, size);
		u8  val;
		casted->GetTransient_PackedPing(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(10, snapAddr, size);
		bool  val;
		casted->GetTransient_bUpdateScoreboard(val);
		memcpy(snapAddr, &val, size);
	}
	
}

void KSnapshot_KEntity_Character_Monster::PackObject(class KSnapshottable* obj)
{
	KEntity_Character_Monster* casted = (KEntity_Character_Monster*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->KillStreak;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReplayPosition(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->KillingPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->PositionForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->Health;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u16  val;
		casted->GetTransient_ReppedPitch(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u16  val;
		casted->GetTransient_ReppedYaw(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u16  val;
		casted->GetTransient_ReplayPitch(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(9, snapAddr, size);
		u16  val;
		casted->GetTransient_ReplayYaw(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(10, snapAddr, size);
		u8* objAddr = (u8*)&casted->SpawnYaw;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(11, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(12, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(13, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(14, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(15, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(16, snapAddr, size);
		u8* objAddr = (u8*)&casted->DamageMultiplier;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Character_Player::PackObject(class KSnapshottable* obj)
{
	KEntity_Character_Player* casted = (KEntity_Character_Player*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->DamageMultiplier;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->KillStreak;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReplayPosition(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->KillingPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->PositionForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->Health;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u16  val;
		casted->GetTransient_ReppedPitch(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u16  val;
		casted->GetTransient_ReppedYaw(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(9, snapAddr, size);
		u16  val;
		casted->GetTransient_ReplayPitch(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(10, snapAddr, size);
		u16  val;
		casted->GetTransient_ReplayYaw(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(11, snapAddr, size);
		u8* objAddr = (u8*)&casted->SpawnYaw;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(12, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(13, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(14, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(15, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(16, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(17, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedWeaponIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(18, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_DeathVelocity(val);
		memcpy(snapAddr, &val, size);
	}
	
}

void KSnapshot_KEntity_Pickup_Health::PackObject(class KSnapshottable* obj)
{
	KEntity_Pickup_Health* casted = (KEntity_Pickup_Health*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReppedFlags;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Pickup_Weapon_Rocket::PackObject(class KSnapshottable* obj)
{
	KEntity_Pickup_Weapon_Rocket* casted = (KEntity_Pickup_Weapon_Rocket*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReppedFlags;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Pickup_Weapon_Cannon::PackObject(class KSnapshottable* obj)
{
	KEntity_Pickup_Weapon_Cannon* casted = (KEntity_Pickup_Weapon_Cannon*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReppedFlags;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Pickup_Weapon_Shotgun::PackObject(class KSnapshottable* obj)
{
	KEntity_Pickup_Weapon_Shotgun* casted = (KEntity_Pickup_Weapon_Shotgun*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReppedFlags;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Pickup_Weapon_Blast::PackObject(class KSnapshottable* obj)
{
	KEntity_Pickup_Weapon_Blast* casted = (KEntity_Pickup_Weapon_Blast*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReppedFlags;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Pickup_Powerup_Brain::PackObject(class KSnapshottable* obj)
{
	KEntity_Pickup_Powerup_Brain* casted = (KEntity_Pickup_Powerup_Brain*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReppedFlags;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u32  val;
		casted->GetTransient_DropDeathFrame(val);
		memcpy(snapAddr, &val, size);
	}
	
}

void KSnapshot_KEntity_Pickup_Powerup_Invis::PackObject(class KSnapshottable* obj)
{
	KEntity_Pickup_Powerup_Invis* casted = (KEntity_Pickup_Powerup_Invis*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReppedFlags;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		KNetVec3  val;
		casted->GetTransient_ReppedNetPos(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->LastPickupEntID;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u32  val;
		casted->GetTransient_DropDeathFrame(val);
		memcpy(snapAddr, &val, size);
	}
	
}

void KSnapshot_KEntity_Powerup_Brain::PackObject(class KSnapshottable* obj)
{
	KEntity_Powerup_Brain* casted = (KEntity_Powerup_Brain*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u32  val;
		casted->GetTransient_EndFrame(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->CarryingEntID;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Powerup_Invis::PackObject(class KSnapshottable* obj)
{
	KEntity_Powerup_Invis* casted = (KEntity_Powerup_Invis*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u32  val;
		casted->GetTransient_EndFrame(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->CarryingEntID;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->bIsInvisible;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Projectile_Atom::PackObject(class KSnapshottable* obj)
{
	KEntity_Projectile_Atom* casted = (KEntity_Projectile_Atom*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedVelocity;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedPosition;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->Health;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u8* objAddr = (u8*)&casted->bPrimaryFire;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Projectile_Blast::PackObject(class KSnapshottable* obj)
{
	KEntity_Projectile_Blast* casted = (KEntity_Projectile_Blast*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedVelocity;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedPosition;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->Health;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u8* objAddr = (u8*)&casted->bPrimaryFire;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(9, snapAddr, size);
		u8* objAddr = (u8*)&casted->DestroyPosition;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Projectile_Cannon::PackObject(class KSnapshottable* obj)
{
	KEntity_Projectile_Cannon* casted = (KEntity_Projectile_Cannon*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedVelocity;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedPosition;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->Health;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u8* objAddr = (u8*)&casted->bPrimaryFire;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Projectile_Rocket::PackObject(class KSnapshottable* obj)
{
	KEntity_Projectile_Rocket* casted = (KEntity_Projectile_Rocket*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedVelocity;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedPosition;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->Health;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u8* objAddr = (u8*)&casted->bPrimaryFire;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(9, snapAddr, size);
		u8* objAddr = (u8*)&casted->DestroyPosition;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(10, snapAddr, size);
		u8* objAddr = (u8*)&casted->DestroyNormal;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Projectile_ShotgunShard::PackObject(class KSnapshottable* obj)
{
	KEntity_Projectile_ShotgunShard* casted = (KEntity_Projectile_ShotgunShard*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedVelocity;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedPosition;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->Health;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u8* objAddr = (u8*)&casted->bPrimaryFire;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Projectile_ShotgunBoulder::PackObject(class KSnapshottable* obj)
{
	KEntity_Projectile_ShotgunBoulder* casted = (KEntity_Projectile_ShotgunBoulder*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedVelocity;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u8* objAddr = (u8*)&casted->ReplicatedPosition;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->Health;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(4, snapAddr, size);
		u8* objAddr = (u8*)&casted->MovementState;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(5, snapAddr, size);
		u8* objAddr = (u8*)&casted->CrouchDepth;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(6, snapAddr, size);
		u8* objAddr = (u8*)&casted->VelocityForOwner;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(7, snapAddr, size);
		u8* objAddr = (u8*)&casted->PushFramesRemaining;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(8, snapAddr, size);
		u8* objAddr = (u8*)&casted->bPrimaryFire;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Weapon_Blast::PackObject(class KSnapshottable* obj)
{
	KEntity_Weapon_Blast* casted = (KEntity_Weapon_Blast*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->AmmoCount;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u32  val;
		casted->GetTransient_OwningEntityID(val);
		memcpy(snapAddr, &val, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(3, snapAddr, size);
		u8* objAddr = (u8*)&casted->bFrenzySound;
				memcpy(snapAddr, objAddr, size);
	}
	
}

void KSnapshot_KEntity_Weapon_Cannon::PackObject(class KSnapshottable* obj)
{
	KEntity_Weapon_Cannon* casted = (KEntity_Weapon_Cannon*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->AmmoCount;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u32  val;
		casted->GetTransient_OwningEntityID(val);
		memcpy(snapAddr, &val, size);
	}
	
}

void KSnapshot_KEntity_Weapon_Rocket::PackObject(class KSnapshottable* obj)
{
	KEntity_Weapon_Rocket* casted = (KEntity_Weapon_Rocket*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->AmmoCount;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u32  val;
		casted->GetTransient_OwningEntityID(val);
		memcpy(snapAddr, &val, size);
	}
	
}

void KSnapshot_KEntity_Weapon_Shotgun::PackObject(class KSnapshottable* obj)
{
	KEntity_Weapon_Shotgun* casted = (KEntity_Weapon_Shotgun*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->AmmoCount;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u32  val;
		casted->GetTransient_OwningEntityID(val);
		memcpy(snapAddr, &val, size);
	}
	
}

void KSnapshot_KEntity_Weapon_Zapper::PackObject(class KSnapshottable* obj)
{
	KEntity_Weapon_Zapper* casted = (KEntity_Weapon_Zapper*)obj;
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(0, snapAddr, size);
		u8* objAddr = (u8*)&casted->OwningPlayerIndex;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(1, snapAddr, size);
		u8* objAddr = (u8*)&casted->AmmoCount;
				memcpy(snapAddr, objAddr, size);
	}
	{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize(2, snapAddr, size);
		u32  val;
		casted->GetTransient_OwningEntityID(val);
		memcpy(snapAddr, &val, size);
	}
	
}


KSnapshot* KSnapshot::GetDefaultSnapshot(u8 classID)
{
	static TVector<UPtr<KSnapshot>> defaults;
	if (defaults.size() == 0)
	{
		defaults.resize(256);
		defaults[223] = std::make_unique<KSnapshot_KNetPlayer>();
		defaults[251] = std::make_unique<KSnapshot_KEntity_Character_Monster>();
		defaults[128] = std::make_unique<KSnapshot_KEntity_Character_Player>();
		defaults[72] = std::make_unique<KSnapshot_KEntity_Pickup_Health>();
		defaults[35] = std::make_unique<KSnapshot_KEntity_Pickup_Weapon_Rocket>();
		defaults[24] = std::make_unique<KSnapshot_KEntity_Pickup_Weapon_Cannon>();
		defaults[163] = std::make_unique<KSnapshot_KEntity_Pickup_Weapon_Shotgun>();
		defaults[177] = std::make_unique<KSnapshot_KEntity_Pickup_Weapon_Blast>();
		defaults[47] = std::make_unique<KSnapshot_KEntity_Pickup_Powerup_Brain>();
		defaults[76] = std::make_unique<KSnapshot_KEntity_Pickup_Powerup_Invis>();
		defaults[100] = std::make_unique<KSnapshot_KEntity_Powerup_Brain>();
		defaults[129] = std::make_unique<KSnapshot_KEntity_Powerup_Invis>();
		defaults[40] = std::make_unique<KSnapshot_KEntity_Projectile_Atom>();
		defaults[141] = std::make_unique<KSnapshot_KEntity_Projectile_Blast>();
		defaults[244] = std::make_unique<KSnapshot_KEntity_Projectile_Cannon>();
		defaults[255] = std::make_unique<KSnapshot_KEntity_Projectile_Rocket>();
		defaults[113] = std::make_unique<KSnapshot_KEntity_Projectile_ShotgunShard>();
		defaults[77] = std::make_unique<KSnapshot_KEntity_Projectile_ShotgunBoulder>();
		defaults[230] = std::make_unique<KSnapshot_KEntity_Weapon_Blast>();
		defaults[78] = std::make_unique<KSnapshot_KEntity_Weapon_Cannon>();
		defaults[88] = std::make_unique<KSnapshot_KEntity_Weapon_Rocket>();
		defaults[216] = std::make_unique<KSnapshot_KEntity_Weapon_Shotgun>();
		defaults[98] = std::make_unique<KSnapshot_KEntity_Weapon_Zapper>();
		
	}
	return defaults[classID].get();
}

KSnapshot* KSnapshot::GetHistoryForObject(u8 classID, u32 netID)
{
	switch (classID)
	{
		case 223:
		{
			return (KSnapshot*)&(SnapshotHistory_KNetPlayer[netID]);
		}
		case 251:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Character_Monster[netID]);
		}
		case 128:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Character_Player[netID]);
		}
		case 72:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Pickup_Health[netID]);
		}
		case 35:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Pickup_Weapon_Rocket[netID]);
		}
		case 24:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Pickup_Weapon_Cannon[netID]);
		}
		case 163:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Pickup_Weapon_Shotgun[netID]);
		}
		case 177:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Pickup_Weapon_Blast[netID]);
		}
		case 47:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Pickup_Powerup_Brain[netID]);
		}
		case 76:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Pickup_Powerup_Invis[netID]);
		}
		case 100:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Powerup_Brain[netID]);
		}
		case 129:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Powerup_Invis[netID]);
		}
		case 40:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Projectile_Atom[netID]);
		}
		case 141:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Projectile_Blast[netID]);
		}
		case 244:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Projectile_Cannon[netID]);
		}
		case 255:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Projectile_Rocket[netID]);
		}
		case 113:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Projectile_ShotgunShard[netID]);
		}
		case 77:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Projectile_ShotgunBoulder[netID]);
		}
		case 230:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Weapon_Blast[netID]);
		}
		case 78:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Weapon_Cannon[netID]);
		}
		case 88:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Weapon_Rocket[netID]);
		}
		case 216:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Weapon_Shotgun[netID]);
		}
		case 98:
		{
			return (KSnapshot*)&(SnapshotHistory_KEntity_Weapon_Zapper[netID]);
		}
		
	}
	return nullptr;
}

KSnapshot* KSnapshot::GetHistoryAtFrame(u32 frame)
{
	if (frame == 0 || KTime::FrameCount() - frame >= MAX_SNAPSHOTS)
		return nullptr;

	return (KSnapshot*)((char*)this + GetClassTypeSize() * (frame % MAX_SNAPSHOTS));
}


void KSnapshot::RemoveObjectFromHistory(u8 classID, u32 netID)
{
	switch (classID)
	{
		case 223: SnapshotHistory_KNetPlayer.erase(netID);
		case 251: SnapshotHistory_KEntity_Character_Monster.erase(netID);
		case 128: SnapshotHistory_KEntity_Character_Player.erase(netID);
		case 72: SnapshotHistory_KEntity_Pickup_Health.erase(netID);
		case 35: SnapshotHistory_KEntity_Pickup_Weapon_Rocket.erase(netID);
		case 24: SnapshotHistory_KEntity_Pickup_Weapon_Cannon.erase(netID);
		case 163: SnapshotHistory_KEntity_Pickup_Weapon_Shotgun.erase(netID);
		case 177: SnapshotHistory_KEntity_Pickup_Weapon_Blast.erase(netID);
		case 47: SnapshotHistory_KEntity_Pickup_Powerup_Brain.erase(netID);
		case 76: SnapshotHistory_KEntity_Pickup_Powerup_Invis.erase(netID);
		case 100: SnapshotHistory_KEntity_Powerup_Brain.erase(netID);
		case 129: SnapshotHistory_KEntity_Powerup_Invis.erase(netID);
		case 40: SnapshotHistory_KEntity_Projectile_Atom.erase(netID);
		case 141: SnapshotHistory_KEntity_Projectile_Blast.erase(netID);
		case 244: SnapshotHistory_KEntity_Projectile_Cannon.erase(netID);
		case 255: SnapshotHistory_KEntity_Projectile_Rocket.erase(netID);
		case 113: SnapshotHistory_KEntity_Projectile_ShotgunShard.erase(netID);
		case 77: SnapshotHistory_KEntity_Projectile_ShotgunBoulder.erase(netID);
		case 230: SnapshotHistory_KEntity_Weapon_Blast.erase(netID);
		case 78: SnapshotHistory_KEntity_Weapon_Cannon.erase(netID);
		case 88: SnapshotHistory_KEntity_Weapon_Rocket.erase(netID);
		case 216: SnapshotHistory_KEntity_Weapon_Shotgun.erase(netID);
		case 98: SnapshotHistory_KEntity_Weapon_Zapper.erase(netID);
		
	}
}

KSnapshottable* KSnapshot::CreateReplicatedObject(u32 classID, u32 netID)
{
	KSnapshottable* out = nullptr;

	switch (classID)
	{
		case 223:
		{
			KNetPlayer* player = new KNetPlayer;
#if !_SERVER
			u32 index = netID & 0x000000FF;
			KNetInterface_Client* c = dynamic_cast<KNetInterface_Client*>(GetNetInterface());
			c->ConnectedPlayers[index] = player;
			player->ClassID = 223;
#endif
			out = player;
			break;
		}
		case 251:
		{
			out = TDataPool<KEntity_Character_Monster>::GetPool()->CreateNew().Get();
			out->ClassID = 251;
			break;
		}
		case 128:
		{
			out = TDataPool<KEntity_Character_Player>::GetPool()->CreateNew().Get();
			out->ClassID = 128;
			break;
		}
		case 72:
		{
			out = TDataPool<KEntity_Pickup_Health>::GetPool()->CreateNew().Get();
			out->ClassID = 72;
			break;
		}
		case 35:
		{
			out = TDataPool<KEntity_Pickup_Weapon_Rocket>::GetPool()->CreateNew().Get();
			out->ClassID = 35;
			break;
		}
		case 24:
		{
			out = TDataPool<KEntity_Pickup_Weapon_Cannon>::GetPool()->CreateNew().Get();
			out->ClassID = 24;
			break;
		}
		case 163:
		{
			out = TDataPool<KEntity_Pickup_Weapon_Shotgun>::GetPool()->CreateNew().Get();
			out->ClassID = 163;
			break;
		}
		case 177:
		{
			out = TDataPool<KEntity_Pickup_Weapon_Blast>::GetPool()->CreateNew().Get();
			out->ClassID = 177;
			break;
		}
		case 47:
		{
			out = TDataPool<KEntity_Pickup_Powerup_Brain>::GetPool()->CreateNew().Get();
			out->ClassID = 47;
			break;
		}
		case 76:
		{
			out = TDataPool<KEntity_Pickup_Powerup_Invis>::GetPool()->CreateNew().Get();
			out->ClassID = 76;
			break;
		}
		case 100:
		{
			out = TDataPool<KEntity_Powerup_Brain>::GetPool()->CreateNew().Get();
			out->ClassID = 100;
			break;
		}
		case 129:
		{
			out = TDataPool<KEntity_Powerup_Invis>::GetPool()->CreateNew().Get();
			out->ClassID = 129;
			break;
		}
		case 40:
		{
			out = TDataPool<KEntity_Projectile_Atom>::GetPool()->CreateNew().Get();
			out->ClassID = 40;
			break;
		}
		case 141:
		{
			out = TDataPool<KEntity_Projectile_Blast>::GetPool()->CreateNew().Get();
			out->ClassID = 141;
			break;
		}
		case 244:
		{
			out = TDataPool<KEntity_Projectile_Cannon>::GetPool()->CreateNew().Get();
			out->ClassID = 244;
			break;
		}
		case 255:
		{
			out = TDataPool<KEntity_Projectile_Rocket>::GetPool()->CreateNew().Get();
			out->ClassID = 255;
			break;
		}
		case 113:
		{
			out = TDataPool<KEntity_Projectile_ShotgunShard>::GetPool()->CreateNew().Get();
			out->ClassID = 113;
			break;
		}
		case 77:
		{
			out = TDataPool<KEntity_Projectile_ShotgunBoulder>::GetPool()->CreateNew().Get();
			out->ClassID = 77;
			break;
		}
		case 230:
		{
			out = TDataPool<KEntity_Weapon_Blast>::GetPool()->CreateNew().Get();
			out->ClassID = 230;
			break;
		}
		case 78:
		{
			out = TDataPool<KEntity_Weapon_Cannon>::GetPool()->CreateNew().Get();
			out->ClassID = 78;
			break;
		}
		case 88:
		{
			out = TDataPool<KEntity_Weapon_Rocket>::GetPool()->CreateNew().Get();
			out->ClassID = 88;
			break;
		}
		case 216:
		{
			out = TDataPool<KEntity_Weapon_Shotgun>::GetPool()->CreateNew().Get();
			out->ClassID = 216;
			break;
		}
		case 98:
		{
			out = TDataPool<KEntity_Weapon_Zapper>::GetPool()->CreateNew().Get();
			out->ClassID = 98;
			break;
		}
		
	}

	if (out)
	{
		out->NetID = netID;
		out->SnapshottableFrameCreated = KTime::FrameCount();
		out->bCreatedFromServer = true;
		if (classID != 223) 
			GetNetState()->AddReplicatedObject(out);
	}

	return out;
}

u32 KSnapshot_KNetPlayer::MemberCount() { return 11; }
u32 KSnapshot_KEntity_Character_Monster::MemberCount() { return 17; }
u32 KSnapshot_KEntity_Character_Player::MemberCount() { return 19; }
u32 KSnapshot_KEntity_Pickup_Health::MemberCount() { return 8; }
u32 KSnapshot_KEntity_Pickup_Weapon_Rocket::MemberCount() { return 8; }
u32 KSnapshot_KEntity_Pickup_Weapon_Cannon::MemberCount() { return 8; }
u32 KSnapshot_KEntity_Pickup_Weapon_Shotgun::MemberCount() { return 8; }
u32 KSnapshot_KEntity_Pickup_Weapon_Blast::MemberCount() { return 8; }
u32 KSnapshot_KEntity_Pickup_Powerup_Brain::MemberCount() { return 9; }
u32 KSnapshot_KEntity_Pickup_Powerup_Invis::MemberCount() { return 9; }
u32 KSnapshot_KEntity_Powerup_Brain::MemberCount() { return 3; }
u32 KSnapshot_KEntity_Powerup_Invis::MemberCount() { return 4; }
u32 KSnapshot_KEntity_Projectile_Atom::MemberCount() { return 9; }
u32 KSnapshot_KEntity_Projectile_Blast::MemberCount() { return 10; }
u32 KSnapshot_KEntity_Projectile_Cannon::MemberCount() { return 9; }
u32 KSnapshot_KEntity_Projectile_Rocket::MemberCount() { return 11; }
u32 KSnapshot_KEntity_Projectile_ShotgunShard::MemberCount() { return 9; }
u32 KSnapshot_KEntity_Projectile_ShotgunBoulder::MemberCount() { return 9; }
u32 KSnapshot_KEntity_Weapon_Blast::MemberCount() { return 4; }
u32 KSnapshot_KEntity_Weapon_Cannon::MemberCount() { return 3; }
u32 KSnapshot_KEntity_Weapon_Rocket::MemberCount() { return 3; }
u32 KSnapshot_KEntity_Weapon_Shotgun::MemberCount() { return 3; }
u32 KSnapshot_KEntity_Weapon_Zapper::MemberCount() { return 3; }


u32 KSnapshot_KNetPlayer::GetClassTypeSize() { return sizeof(KSnapshot_KNetPlayer); }
u32 KSnapshot_KEntity_Character_Monster::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Character_Monster); }
u32 KSnapshot_KEntity_Character_Player::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Character_Player); }
u32 KSnapshot_KEntity_Pickup_Health::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Pickup_Health); }
u32 KSnapshot_KEntity_Pickup_Weapon_Rocket::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Pickup_Weapon_Rocket); }
u32 KSnapshot_KEntity_Pickup_Weapon_Cannon::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Pickup_Weapon_Cannon); }
u32 KSnapshot_KEntity_Pickup_Weapon_Shotgun::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Pickup_Weapon_Shotgun); }
u32 KSnapshot_KEntity_Pickup_Weapon_Blast::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Pickup_Weapon_Blast); }
u32 KSnapshot_KEntity_Pickup_Powerup_Brain::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Pickup_Powerup_Brain); }
u32 KSnapshot_KEntity_Pickup_Powerup_Invis::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Pickup_Powerup_Invis); }
u32 KSnapshot_KEntity_Powerup_Brain::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Powerup_Brain); }
u32 KSnapshot_KEntity_Powerup_Invis::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Powerup_Invis); }
u32 KSnapshot_KEntity_Projectile_Atom::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Projectile_Atom); }
u32 KSnapshot_KEntity_Projectile_Blast::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Projectile_Blast); }
u32 KSnapshot_KEntity_Projectile_Cannon::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Projectile_Cannon); }
u32 KSnapshot_KEntity_Projectile_Rocket::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Projectile_Rocket); }
u32 KSnapshot_KEntity_Projectile_ShotgunShard::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Projectile_ShotgunShard); }
u32 KSnapshot_KEntity_Projectile_ShotgunBoulder::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Projectile_ShotgunBoulder); }
u32 KSnapshot_KEntity_Weapon_Blast::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Weapon_Blast); }
u32 KSnapshot_KEntity_Weapon_Cannon::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Weapon_Cannon); }
u32 KSnapshot_KEntity_Weapon_Rocket::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Weapon_Rocket); }
u32 KSnapshot_KEntity_Weapon_Shotgun::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Weapon_Shotgun); }
u32 KSnapshot_KEntity_Weapon_Zapper::GetClassTypeSize() { return sizeof(KSnapshot_KEntity_Weapon_Zapper); }


void KSnapshot_KNetPlayer::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReppedName;
			size = sizeof(KReppedPlayerName);
			break;
		case 2:
			addr = (u8*)&LastInputFrame;
			size = sizeof(u32);
			break;
		case 3:
			addr = (u8*)&LastAckedFrame;
			size = sizeof(u32);
			break;
		case 4:
			addr = (u8*)&TotalFrameDrops;
			size = sizeof(u8);
			break;
		case 5:
			addr = (u8*)&Score;
			size = sizeof(i32);
			break;
		case 6:
			addr = (u8*)&Frags;
			size = sizeof(i32);
			break;
		case 7:
			addr = (u8*)&Deaths;
			size = sizeof(i32);
			break;
		case 8:
			addr = (u8*)&Damage;
			size = sizeof(i32);
			break;
		case 9:
			addr = (u8*)&PackedPing;
			size = sizeof(u8);
			break;
		case 10:
			addr = (u8*)&bUpdateScoreboard;
			size = sizeof(bool);
			break;
		
	}
}
void KSnapshot_KEntity_Character_Monster::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&KillStreak;
			size = sizeof(u16);
			break;
		case 2:
			addr = (u8*)&ReplayPosition;
			size = sizeof(KNetVec3);
			break;
		case 3:
			addr = (u8*)&KillingPlayerIndex;
			size = sizeof(u8);
			break;
		case 4:
			addr = (u8*)&PositionForOwner;
			size = sizeof(GVec3);
			break;
		case 5:
			addr = (u8*)&Health;
			size = sizeof(i16);
			break;
		case 6:
			addr = (u8*)&ReppedPitch;
			size = sizeof(u16);
			break;
		case 7:
			addr = (u8*)&ReppedYaw;
			size = sizeof(u16);
			break;
		case 8:
			addr = (u8*)&ReplayPitch;
			size = sizeof(u16);
			break;
		case 9:
			addr = (u8*)&ReplayYaw;
			size = sizeof(u16);
			break;
		case 10:
			addr = (u8*)&SpawnYaw;
			size = sizeof(u16);
			break;
		case 11:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 12:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 13:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 14:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 15:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 16:
			addr = (u8*)&DamageMultiplier;
			size = sizeof(f32);
			break;
		
	}
}
void KSnapshot_KEntity_Character_Player::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&DamageMultiplier;
			size = sizeof(f32);
			break;
		case 2:
			addr = (u8*)&KillStreak;
			size = sizeof(u16);
			break;
		case 3:
			addr = (u8*)&ReplayPosition;
			size = sizeof(KNetVec3);
			break;
		case 4:
			addr = (u8*)&KillingPlayerIndex;
			size = sizeof(u8);
			break;
		case 5:
			addr = (u8*)&PositionForOwner;
			size = sizeof(GVec3);
			break;
		case 6:
			addr = (u8*)&Health;
			size = sizeof(i16);
			break;
		case 7:
			addr = (u8*)&ReppedPitch;
			size = sizeof(u16);
			break;
		case 8:
			addr = (u8*)&ReppedYaw;
			size = sizeof(u16);
			break;
		case 9:
			addr = (u8*)&ReplayPitch;
			size = sizeof(u16);
			break;
		case 10:
			addr = (u8*)&ReplayYaw;
			size = sizeof(u16);
			break;
		case 11:
			addr = (u8*)&SpawnYaw;
			size = sizeof(u16);
			break;
		case 12:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 13:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 14:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 15:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 16:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 17:
			addr = (u8*)&ReplicatedWeaponIndex;
			size = sizeof(u8);
			break;
		case 18:
			addr = (u8*)&DeathVelocity;
			size = sizeof(KNetVec3);
			break;
		
	}
}
void KSnapshot_KEntity_Pickup_Health::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&LastPickupEntID;
			size = sizeof(u32);
			break;
		case 2:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 3:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 4:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 5:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 6:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 7:
			addr = (u8*)&ReppedFlags;
			size = sizeof(u8);
			break;
		
	}
}
void KSnapshot_KEntity_Pickup_Weapon_Rocket::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 2:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 3:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 6:
			addr = (u8*)&LastPickupEntID;
			size = sizeof(u32);
			break;
		case 7:
			addr = (u8*)&ReppedFlags;
			size = sizeof(u8);
			break;
		
	}
}
void KSnapshot_KEntity_Pickup_Weapon_Cannon::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 2:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 3:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 6:
			addr = (u8*)&LastPickupEntID;
			size = sizeof(u32);
			break;
		case 7:
			addr = (u8*)&ReppedFlags;
			size = sizeof(u8);
			break;
		
	}
}
void KSnapshot_KEntity_Pickup_Weapon_Shotgun::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 2:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 3:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 6:
			addr = (u8*)&LastPickupEntID;
			size = sizeof(u32);
			break;
		case 7:
			addr = (u8*)&ReppedFlags;
			size = sizeof(u8);
			break;
		
	}
}
void KSnapshot_KEntity_Pickup_Weapon_Blast::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 2:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 3:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 6:
			addr = (u8*)&LastPickupEntID;
			size = sizeof(u32);
			break;
		case 7:
			addr = (u8*)&ReppedFlags;
			size = sizeof(u8);
			break;
		
	}
}
void KSnapshot_KEntity_Pickup_Powerup_Brain::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReppedFlags;
			size = sizeof(u8);
			break;
		case 2:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 3:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 4:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 5:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 6:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 7:
			addr = (u8*)&LastPickupEntID;
			size = sizeof(u32);
			break;
		case 8:
			addr = (u8*)&DropDeathFrame;
			size = sizeof(u32);
			break;
		
	}
}
void KSnapshot_KEntity_Pickup_Powerup_Invis::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReppedFlags;
			size = sizeof(u8);
			break;
		case 2:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 3:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 4:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 5:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 6:
			addr = (u8*)&ReppedNetPos;
			size = sizeof(KNetVec3);
			break;
		case 7:
			addr = (u8*)&LastPickupEntID;
			size = sizeof(u32);
			break;
		case 8:
			addr = (u8*)&DropDeathFrame;
			size = sizeof(u32);
			break;
		
	}
}
void KSnapshot_KEntity_Powerup_Brain::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&EndFrame;
			size = sizeof(u32);
			break;
		case 2:
			addr = (u8*)&CarryingEntID;
			size = sizeof(u32);
			break;
		
	}
}
void KSnapshot_KEntity_Powerup_Invis::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&EndFrame;
			size = sizeof(u32);
			break;
		case 2:
			addr = (u8*)&CarryingEntID;
			size = sizeof(u32);
			break;
		case 3:
			addr = (u8*)&bIsInvisible;
			size = sizeof(bool);
			break;
		
	}
}
void KSnapshot_KEntity_Projectile_Atom::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReplicatedVelocity;
			size = sizeof(KNetVec3);
			break;
		case 2:
			addr = (u8*)&ReplicatedPosition;
			size = sizeof(KNetVec3);
			break;
		case 3:
			addr = (u8*)&Health;
			size = sizeof(i16);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 6:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 7:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 8:
			addr = (u8*)&bPrimaryFire;
			size = sizeof(bool);
			break;
		
	}
}
void KSnapshot_KEntity_Projectile_Blast::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReplicatedVelocity;
			size = sizeof(KNetVec3);
			break;
		case 2:
			addr = (u8*)&ReplicatedPosition;
			size = sizeof(KNetVec3);
			break;
		case 3:
			addr = (u8*)&Health;
			size = sizeof(i16);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 6:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 7:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 8:
			addr = (u8*)&bPrimaryFire;
			size = sizeof(bool);
			break;
		case 9:
			addr = (u8*)&DestroyPosition;
			size = sizeof(KNetVec3);
			break;
		
	}
}
void KSnapshot_KEntity_Projectile_Cannon::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReplicatedVelocity;
			size = sizeof(KNetVec3);
			break;
		case 2:
			addr = (u8*)&ReplicatedPosition;
			size = sizeof(KNetVec3);
			break;
		case 3:
			addr = (u8*)&Health;
			size = sizeof(i16);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 6:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 7:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 8:
			addr = (u8*)&bPrimaryFire;
			size = sizeof(bool);
			break;
		
	}
}
void KSnapshot_KEntity_Projectile_Rocket::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReplicatedVelocity;
			size = sizeof(KNetVec3);
			break;
		case 2:
			addr = (u8*)&ReplicatedPosition;
			size = sizeof(KNetVec3);
			break;
		case 3:
			addr = (u8*)&Health;
			size = sizeof(i16);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 6:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 7:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 8:
			addr = (u8*)&bPrimaryFire;
			size = sizeof(bool);
			break;
		case 9:
			addr = (u8*)&DestroyPosition;
			size = sizeof(KNetVec3);
			break;
		case 10:
			addr = (u8*)&DestroyNormal;
			size = sizeof(KNetVec3);
			break;
		
	}
}
void KSnapshot_KEntity_Projectile_ShotgunShard::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReplicatedVelocity;
			size = sizeof(KNetVec3);
			break;
		case 2:
			addr = (u8*)&ReplicatedPosition;
			size = sizeof(KNetVec3);
			break;
		case 3:
			addr = (u8*)&Health;
			size = sizeof(i16);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 6:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 7:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 8:
			addr = (u8*)&bPrimaryFire;
			size = sizeof(bool);
			break;
		
	}
}
void KSnapshot_KEntity_Projectile_ShotgunBoulder::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&ReplicatedVelocity;
			size = sizeof(KNetVec3);
			break;
		case 2:
			addr = (u8*)&ReplicatedPosition;
			size = sizeof(KNetVec3);
			break;
		case 3:
			addr = (u8*)&Health;
			size = sizeof(i16);
			break;
		case 4:
			addr = (u8*)&MovementState;
			size = sizeof(EMoveState);
			break;
		case 5:
			addr = (u8*)&CrouchDepth;
			size = sizeof(u8);
			break;
		case 6:
			addr = (u8*)&VelocityForOwner;
			size = sizeof(GVec3);
			break;
		case 7:
			addr = (u8*)&PushFramesRemaining;
			size = sizeof(u8);
			break;
		case 8:
			addr = (u8*)&bPrimaryFire;
			size = sizeof(bool);
			break;
		
	}
}
void KSnapshot_KEntity_Weapon_Blast::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&AmmoCount;
			size = sizeof(u16);
			break;
		case 2:
			addr = (u8*)&OwningEntityID;
			size = sizeof(u32);
			break;
		case 3:
			addr = (u8*)&bFrenzySound;
			size = sizeof(bool);
			break;
		
	}
}
void KSnapshot_KEntity_Weapon_Cannon::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&AmmoCount;
			size = sizeof(u16);
			break;
		case 2:
			addr = (u8*)&OwningEntityID;
			size = sizeof(u32);
			break;
		
	}
}
void KSnapshot_KEntity_Weapon_Rocket::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&AmmoCount;
			size = sizeof(u16);
			break;
		case 2:
			addr = (u8*)&OwningEntityID;
			size = sizeof(u32);
			break;
		
	}
}
void KSnapshot_KEntity_Weapon_Shotgun::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&AmmoCount;
			size = sizeof(u16);
			break;
		case 2:
			addr = (u8*)&OwningEntityID;
			size = sizeof(u32);
			break;
		
	}
}
void KSnapshot_KEntity_Weapon_Zapper::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		case 0:
			addr = (u8*)&OwningPlayerIndex;
			size = sizeof(u8);
			break;
		case 1:
			addr = (u8*)&AmmoCount;
			size = sizeof(u16);
			break;
		case 2:
			addr = (u8*)&OwningEntityID;
			size = sizeof(u32);
			break;
		
	}
}



bool KSnapshot_KNetPlayer::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return !storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 3: return !storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return !storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 5: return true;
		case 6: return true;
		case 7: return true;
		case 8: return true;
		case 9: return true;
		case 10: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		
	}
	return false;
}

bool KSnapshot_KEntity_Character_Monster::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 3: return true;
		case 4: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 7: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 8: return storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 9: return storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 10: return (lastAcked < object->SnapshottableFrameCreated) && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 11: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 12: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 13: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 14: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 15: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 16: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Character_Player::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return true;
		case 3: return storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return true;
		case 5: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 7: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 8: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 9: return storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 10: return storingReplay && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 11: return (lastAcked < object->SnapshottableFrameCreated) && (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 12: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 13: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 14: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 15: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 16: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 17: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 18: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Pickup_Health::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 3: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 7: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Pickup_Weapon_Rocket::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 2: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 3: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return true;
		case 7: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Pickup_Weapon_Cannon::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 2: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 3: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return true;
		case 7: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Pickup_Weapon_Shotgun::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 2: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 3: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return true;
		case 7: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Pickup_Weapon_Blast::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 2: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 3: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return true;
		case 7: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Pickup_Powerup_Brain::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 3: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 7: return true;
		case 8: return (lastAcked < object->SnapshottableFrameCreated);
		
	}
	return false;
}

bool KSnapshot_KEntity_Pickup_Powerup_Invis::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 3: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 7: return true;
		case 8: return (lastAcked < object->SnapshottableFrameCreated);
		
	}
	return false;
}

bool KSnapshot_KEntity_Powerup_Brain::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return (lastAcked < object->SnapshottableFrameCreated);
		
	}
	return false;
}

bool KSnapshot_KEntity_Powerup_Invis::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return (lastAcked < object->SnapshottableFrameCreated);
		case 3: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Projectile_Atom::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (lastAcked < object->SnapshottableFrameCreated);
		case 2: return (lastAcked < object->SnapshottableFrameCreated);
		case 3: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 7: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 8: return (lastAcked < object->SnapshottableFrameCreated);
		
	}
	return false;
}

bool KSnapshot_KEntity_Projectile_Blast::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (lastAcked < object->SnapshottableFrameCreated);
		case 2: return (lastAcked < object->SnapshottableFrameCreated);
		case 3: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 7: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 8: return (lastAcked < object->SnapshottableFrameCreated);
		case 9: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		
	}
	return false;
}

bool KSnapshot_KEntity_Projectile_Cannon::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (lastAcked < object->SnapshottableFrameCreated);
		case 2: return (lastAcked < object->SnapshottableFrameCreated);
		case 3: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 7: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 8: return (lastAcked < object->SnapshottableFrameCreated);
		
	}
	return false;
}

bool KSnapshot_KEntity_Projectile_Rocket::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (lastAcked < object->SnapshottableFrameCreated);
		case 2: return (lastAcked < object->SnapshottableFrameCreated);
		case 3: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 7: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 8: return (lastAcked < object->SnapshottableFrameCreated);
		case 9: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 10: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		
	}
	return false;
}

bool KSnapshot_KEntity_Projectile_ShotgunShard::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (lastAcked < object->SnapshottableFrameCreated);
		case 2: return (lastAcked < object->SnapshottableFrameCreated);
		case 3: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 7: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 8: return (lastAcked < object->SnapshottableFrameCreated);
		
	}
	return false;
}

bool KSnapshot_KEntity_Projectile_ShotgunBoulder::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return (lastAcked < object->SnapshottableFrameCreated);
		case 2: return (lastAcked < object->SnapshottableFrameCreated);
		case 3: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 4: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 5: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		case 6: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 7: return (playerIndex == object->OwningPlayerIndex || storingReplay);
		case 8: return (lastAcked < object->SnapshottableFrameCreated);
		
	}
	return false;
}

bool KSnapshot_KEntity_Weapon_Blast::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return true;
		case 3: return (playerIndex != object->OwningPlayerIndex || storingReplay);
		
	}
	return false;
}

bool KSnapshot_KEntity_Weapon_Cannon::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Weapon_Rocket::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Weapon_Shotgun::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return true;
		
	}
	return false;
}

bool KSnapshot_KEntity_Weapon_Zapper::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		case 0: return true;
		case 1: return true;
		case 2: return true;
		
	}
	return false;
}


u32 KSnapshot::Apply(u8 index, KSnapshottable* object, const u8* data)
{
	switch (object->ClassID)
	{
		case 223:
		{
			KNetPlayer* casted = (KNetPlayer*)object;
			return KSnapshot_KNetPlayer::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 251:
		{
			KEntity_Character_Monster* casted = (KEntity_Character_Monster*)object;
			return KSnapshot_KEntity_Character_Monster::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 128:
		{
			KEntity_Character_Player* casted = (KEntity_Character_Player*)object;
			return KSnapshot_KEntity_Character_Player::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 72:
		{
			KEntity_Pickup_Health* casted = (KEntity_Pickup_Health*)object;
			return KSnapshot_KEntity_Pickup_Health::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 35:
		{
			KEntity_Pickup_Weapon_Rocket* casted = (KEntity_Pickup_Weapon_Rocket*)object;
			return KSnapshot_KEntity_Pickup_Weapon_Rocket::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 24:
		{
			KEntity_Pickup_Weapon_Cannon* casted = (KEntity_Pickup_Weapon_Cannon*)object;
			return KSnapshot_KEntity_Pickup_Weapon_Cannon::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 163:
		{
			KEntity_Pickup_Weapon_Shotgun* casted = (KEntity_Pickup_Weapon_Shotgun*)object;
			return KSnapshot_KEntity_Pickup_Weapon_Shotgun::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 177:
		{
			KEntity_Pickup_Weapon_Blast* casted = (KEntity_Pickup_Weapon_Blast*)object;
			return KSnapshot_KEntity_Pickup_Weapon_Blast::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 47:
		{
			KEntity_Pickup_Powerup_Brain* casted = (KEntity_Pickup_Powerup_Brain*)object;
			return KSnapshot_KEntity_Pickup_Powerup_Brain::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 76:
		{
			KEntity_Pickup_Powerup_Invis* casted = (KEntity_Pickup_Powerup_Invis*)object;
			return KSnapshot_KEntity_Pickup_Powerup_Invis::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 100:
		{
			KEntity_Powerup_Brain* casted = (KEntity_Powerup_Brain*)object;
			return KSnapshot_KEntity_Powerup_Brain::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 129:
		{
			KEntity_Powerup_Invis* casted = (KEntity_Powerup_Invis*)object;
			return KSnapshot_KEntity_Powerup_Invis::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 40:
		{
			KEntity_Projectile_Atom* casted = (KEntity_Projectile_Atom*)object;
			return KSnapshot_KEntity_Projectile_Atom::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 141:
		{
			KEntity_Projectile_Blast* casted = (KEntity_Projectile_Blast*)object;
			return KSnapshot_KEntity_Projectile_Blast::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 244:
		{
			KEntity_Projectile_Cannon* casted = (KEntity_Projectile_Cannon*)object;
			return KSnapshot_KEntity_Projectile_Cannon::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 255:
		{
			KEntity_Projectile_Rocket* casted = (KEntity_Projectile_Rocket*)object;
			return KSnapshot_KEntity_Projectile_Rocket::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 113:
		{
			KEntity_Projectile_ShotgunShard* casted = (KEntity_Projectile_ShotgunShard*)object;
			return KSnapshot_KEntity_Projectile_ShotgunShard::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 77:
		{
			KEntity_Projectile_ShotgunBoulder* casted = (KEntity_Projectile_ShotgunBoulder*)object;
			return KSnapshot_KEntity_Projectile_ShotgunBoulder::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 230:
		{
			KEntity_Weapon_Blast* casted = (KEntity_Weapon_Blast*)object;
			return KSnapshot_KEntity_Weapon_Blast::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 78:
		{
			KEntity_Weapon_Cannon* casted = (KEntity_Weapon_Cannon*)object;
			return KSnapshot_KEntity_Weapon_Cannon::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 88:
		{
			KEntity_Weapon_Rocket* casted = (KEntity_Weapon_Rocket*)object;
			return KSnapshot_KEntity_Weapon_Rocket::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 216:
		{
			KEntity_Weapon_Shotgun* casted = (KEntity_Weapon_Shotgun*)object;
			return KSnapshot_KEntity_Weapon_Shotgun::ApplyPropertyToObject(index, casted, data);
			break;
		}
		case 98:
		{
			KEntity_Weapon_Zapper* casted = (KEntity_Weapon_Zapper*)object;
			return KSnapshot_KEntity_Weapon_Zapper::ApplyPropertyToObject(index, casted, data);
			break;
		}
		
	}

	return 0;
}

u32 KSnapshot_KNetPlayer::ApplyPropertyToObject(u8 index, KNetPlayer* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			KReppedPlayerName prop;
			memcpy(&prop, data, sizeof(KReppedPlayerName));
			object->SetTransient_ReppedName(prop);
			
			return sizeof(KReppedPlayerName);
		}
		case 2:
		{
			memcpy(&object->LastInputFrame, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 3:
		{
			memcpy(&object->LastAckedFrame, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 4:
		{
			memcpy(&object->TotalFrameDrops, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 5:
		{
			memcpy(&object->Score, data, sizeof(i32));
			
			return sizeof(i32);
		}
		case 6:
		{
			memcpy(&object->Frags, data, sizeof(i32));
			
			return sizeof(i32);
		}
		case 7:
		{
			memcpy(&object->Deaths, data, sizeof(i32));
			
			return sizeof(i32);
		}
		case 8:
		{
			memcpy(&object->Damage, data, sizeof(i32));
			
			return sizeof(i32);
		}
		case 9:
		{
			u8 prop;
			memcpy(&prop, data, sizeof(u8));
			object->SetTransient_PackedPing(prop);
			
			return sizeof(u8);
		}
		case 10:
		{
			bool prop;
			memcpy(&prop, data, sizeof(bool));
			object->SetTransient_bUpdateScoreboard(prop);
			
			return sizeof(bool);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Character_Monster::ApplyPropertyToObject(u8 index, KEntity_Character_Monster* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->KillStreak, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 2:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReplayPosition(prop);
			
			return sizeof(KNetVec3);
		}
		case 3:
		{
			memcpy(&object->KillingPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 4:
		{
			memcpy(&object->PositionForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 5:
		{
			memcpy(&object->Health, data, sizeof(i16));
			
			return sizeof(i16);
		}
		case 6:
		{
			u16 prop;
			memcpy(&prop, data, sizeof(u16));
			object->SetTransient_ReppedPitch(prop);
			
			return sizeof(u16);
		}
		case 7:
		{
			u16 prop;
			memcpy(&prop, data, sizeof(u16));
			object->SetTransient_ReppedYaw(prop);
			
			return sizeof(u16);
		}
		case 8:
		{
			u16 prop;
			memcpy(&prop, data, sizeof(u16));
			object->SetTransient_ReplayPitch(prop);
			
			return sizeof(u16);
		}
		case 9:
		{
			u16 prop;
			memcpy(&prop, data, sizeof(u16));
			object->SetTransient_ReplayYaw(prop);
			
			return sizeof(u16);
		}
		case 10:
		{
			memcpy(&object->SpawnYaw, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 11:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 12:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 13:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 14:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 15:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 16:
		{
			memcpy(&object->DamageMultiplier, data, sizeof(f32));
			
			return sizeof(f32);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Character_Player::ApplyPropertyToObject(u8 index, KEntity_Character_Player* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->DamageMultiplier, data, sizeof(f32));
			
			return sizeof(f32);
		}
		case 2:
		{
			memcpy(&object->KillStreak, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 3:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReplayPosition(prop);
			
			return sizeof(KNetVec3);
		}
		case 4:
		{
			memcpy(&object->KillingPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 5:
		{
			memcpy(&object->PositionForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 6:
		{
			memcpy(&object->Health, data, sizeof(i16));
			
			return sizeof(i16);
		}
		case 7:
		{
			u16 prop;
			memcpy(&prop, data, sizeof(u16));
			object->SetTransient_ReppedPitch(prop);
			
			return sizeof(u16);
		}
		case 8:
		{
			u16 prop;
			memcpy(&prop, data, sizeof(u16));
			object->SetTransient_ReppedYaw(prop);
			
			return sizeof(u16);
		}
		case 9:
		{
			u16 prop;
			memcpy(&prop, data, sizeof(u16));
			object->SetTransient_ReplayPitch(prop);
			
			return sizeof(u16);
		}
		case 10:
		{
			u16 prop;
			memcpy(&prop, data, sizeof(u16));
			object->SetTransient_ReplayYaw(prop);
			
			return sizeof(u16);
		}
		case 11:
		{
			memcpy(&object->SpawnYaw, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 12:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 13:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 14:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 15:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 16:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 17:
		{
			memcpy(&object->ReplicatedWeaponIndex, data, sizeof(u8));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 17;
			PendingOnReps.push_back(rep);
			return sizeof(u8);
		}
		case 18:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_DeathVelocity(prop);
			
			return sizeof(KNetVec3);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Pickup_Health::ApplyPropertyToObject(u8 index, KEntity_Pickup_Health* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->LastPickupEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 2:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 3:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 4:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 5:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 6:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 7:
		{
			memcpy(&object->ReppedFlags, data, sizeof(u8));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 7;
			PendingOnReps.push_back(rep);
			return sizeof(u8);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Pickup_Weapon_Rocket::ApplyPropertyToObject(u8 index, KEntity_Pickup_Weapon_Rocket* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 2:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 3:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 6:
		{
			memcpy(&object->LastPickupEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 7:
		{
			memcpy(&object->ReppedFlags, data, sizeof(u8));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 7;
			PendingOnReps.push_back(rep);
			return sizeof(u8);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Pickup_Weapon_Cannon::ApplyPropertyToObject(u8 index, KEntity_Pickup_Weapon_Cannon* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 2:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 3:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 6:
		{
			memcpy(&object->LastPickupEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 7:
		{
			memcpy(&object->ReppedFlags, data, sizeof(u8));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 7;
			PendingOnReps.push_back(rep);
			return sizeof(u8);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Pickup_Weapon_Shotgun::ApplyPropertyToObject(u8 index, KEntity_Pickup_Weapon_Shotgun* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 2:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 3:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 6:
		{
			memcpy(&object->LastPickupEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 7:
		{
			memcpy(&object->ReppedFlags, data, sizeof(u8));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 7;
			PendingOnReps.push_back(rep);
			return sizeof(u8);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Pickup_Weapon_Blast::ApplyPropertyToObject(u8 index, KEntity_Pickup_Weapon_Blast* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 2:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 3:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 6:
		{
			memcpy(&object->LastPickupEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 7:
		{
			memcpy(&object->ReppedFlags, data, sizeof(u8));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 7;
			PendingOnReps.push_back(rep);
			return sizeof(u8);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Pickup_Powerup_Brain::ApplyPropertyToObject(u8 index, KEntity_Pickup_Powerup_Brain* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->ReppedFlags, data, sizeof(u8));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 1;
			PendingOnReps.push_back(rep);
			return sizeof(u8);
		}
		case 2:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 3:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 4:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 5:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 6:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 7:
		{
			memcpy(&object->LastPickupEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 8:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_DropDeathFrame(prop);
			
			return sizeof(u32);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Pickup_Powerup_Invis::ApplyPropertyToObject(u8 index, KEntity_Pickup_Powerup_Invis* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->ReppedFlags, data, sizeof(u8));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 1;
			PendingOnReps.push_back(rep);
			return sizeof(u8);
		}
		case 2:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 3:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 4:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 5:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 6:
		{
			KNetVec3 prop;
			memcpy(&prop, data, sizeof(KNetVec3));
			object->SetTransient_ReppedNetPos(prop);
			
			return sizeof(KNetVec3);
		}
		case 7:
		{
			memcpy(&object->LastPickupEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 8:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_DropDeathFrame(prop);
			
			return sizeof(u32);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Powerup_Brain::ApplyPropertyToObject(u8 index, KEntity_Powerup_Brain* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_EndFrame(prop);
			
			return sizeof(u32);
		}
		case 2:
		{
			memcpy(&object->CarryingEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Powerup_Invis::ApplyPropertyToObject(u8 index, KEntity_Powerup_Invis* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_EndFrame(prop);
			
			return sizeof(u32);
		}
		case 2:
		{
			memcpy(&object->CarryingEntID, data, sizeof(u32));
			
			return sizeof(u32);
		}
		case 3:
		{
			memcpy(&object->bIsInvisible, data, sizeof(bool));
			KPendingOnRep rep;
			rep.Object = object;
			rep.Index = 3;
			PendingOnReps.push_back(rep);
			return sizeof(bool);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Projectile_Atom::ApplyPropertyToObject(u8 index, KEntity_Projectile_Atom* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->ReplicatedVelocity, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 2:
		{
			memcpy(&object->ReplicatedPosition, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 3:
		{
			memcpy(&object->Health, data, sizeof(i16));
			
			return sizeof(i16);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 6:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 7:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 8:
		{
			memcpy(&object->bPrimaryFire, data, sizeof(bool));
			
			return sizeof(bool);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Projectile_Blast::ApplyPropertyToObject(u8 index, KEntity_Projectile_Blast* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->ReplicatedVelocity, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 2:
		{
			memcpy(&object->ReplicatedPosition, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 3:
		{
			memcpy(&object->Health, data, sizeof(i16));
			
			return sizeof(i16);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 6:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 7:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 8:
		{
			memcpy(&object->bPrimaryFire, data, sizeof(bool));
			
			return sizeof(bool);
		}
		case 9:
		{
			memcpy(&object->DestroyPosition, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Projectile_Cannon::ApplyPropertyToObject(u8 index, KEntity_Projectile_Cannon* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->ReplicatedVelocity, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 2:
		{
			memcpy(&object->ReplicatedPosition, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 3:
		{
			memcpy(&object->Health, data, sizeof(i16));
			
			return sizeof(i16);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 6:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 7:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 8:
		{
			memcpy(&object->bPrimaryFire, data, sizeof(bool));
			
			return sizeof(bool);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Projectile_Rocket::ApplyPropertyToObject(u8 index, KEntity_Projectile_Rocket* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->ReplicatedVelocity, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 2:
		{
			memcpy(&object->ReplicatedPosition, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 3:
		{
			memcpy(&object->Health, data, sizeof(i16));
			
			return sizeof(i16);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 6:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 7:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 8:
		{
			memcpy(&object->bPrimaryFire, data, sizeof(bool));
			
			return sizeof(bool);
		}
		case 9:
		{
			memcpy(&object->DestroyPosition, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 10:
		{
			memcpy(&object->DestroyNormal, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Projectile_ShotgunShard::ApplyPropertyToObject(u8 index, KEntity_Projectile_ShotgunShard* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->ReplicatedVelocity, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 2:
		{
			memcpy(&object->ReplicatedPosition, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 3:
		{
			memcpy(&object->Health, data, sizeof(i16));
			
			return sizeof(i16);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 6:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 7:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 8:
		{
			memcpy(&object->bPrimaryFire, data, sizeof(bool));
			
			return sizeof(bool);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Projectile_ShotgunBoulder::ApplyPropertyToObject(u8 index, KEntity_Projectile_ShotgunBoulder* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->ReplicatedVelocity, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 2:
		{
			memcpy(&object->ReplicatedPosition, data, sizeof(KNetVec3));
			
			return sizeof(KNetVec3);
		}
		case 3:
		{
			memcpy(&object->Health, data, sizeof(i16));
			
			return sizeof(i16);
		}
		case 4:
		{
			memcpy(&object->MovementState, data, sizeof(EMoveState));
			
			return sizeof(EMoveState);
		}
		case 5:
		{
			memcpy(&object->CrouchDepth, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 6:
		{
			memcpy(&object->VelocityForOwner, data, sizeof(GVec3));
			
			return sizeof(GVec3);
		}
		case 7:
		{
			memcpy(&object->PushFramesRemaining, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 8:
		{
			memcpy(&object->bPrimaryFire, data, sizeof(bool));
			
			return sizeof(bool);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Weapon_Blast::ApplyPropertyToObject(u8 index, KEntity_Weapon_Blast* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->AmmoCount, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 2:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_OwningEntityID(prop);
			
			return sizeof(u32);
		}
		case 3:
		{
			memcpy(&object->bFrenzySound, data, sizeof(bool));
			
			return sizeof(bool);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Weapon_Cannon::ApplyPropertyToObject(u8 index, KEntity_Weapon_Cannon* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->AmmoCount, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 2:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_OwningEntityID(prop);
			
			return sizeof(u32);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Weapon_Rocket::ApplyPropertyToObject(u8 index, KEntity_Weapon_Rocket* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->AmmoCount, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 2:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_OwningEntityID(prop);
			
			return sizeof(u32);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Weapon_Shotgun::ApplyPropertyToObject(u8 index, KEntity_Weapon_Shotgun* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->AmmoCount, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 2:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_OwningEntityID(prop);
			
			return sizeof(u32);
		}
	}

	return 0;
}

u32 KSnapshot_KEntity_Weapon_Zapper::ApplyPropertyToObject(u8 index, KEntity_Weapon_Zapper* object, const u8* data)
{
	switch (index)
	{
		
		case 0:
		{
			memcpy(&object->OwningPlayerIndex, data, sizeof(u8));
			
			return sizeof(u8);
		}
		case 1:
		{
			memcpy(&object->AmmoCount, data, sizeof(u16));
			
			return sizeof(u16);
		}
		case 2:
		{
			u32 prop;
			memcpy(&prop, data, sizeof(u32));
			object->SetTransient_OwningEntityID(prop);
			
			return sizeof(u32);
		}
	}

	return 0;
}



void KSnapshot::ApplyOnReps(bool destroy)
{
	TVector<KPendingOnRep>& reps = destroy ? DestroyPendingOnReps : PendingOnReps;

	for (KPendingOnRep& r : reps)
	{
		switch (r.Object->ClassID)
		{
			case 223:
			{
				if (destroy)
					KDestroySnapshot_KNetPlayer::ApplyOnRep((KNetPlayer*)r.Object, r.Index);
				else
					KSnapshot_KNetPlayer::ApplyOnRep((KNetPlayer*)r.Object, r.Index);
				break;
			}
			case 251:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Character_Monster::ApplyOnRep((KEntity_Character_Monster*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Character_Monster::ApplyOnRep((KEntity_Character_Monster*)r.Object, r.Index);
				break;
			}
			case 128:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Character_Player::ApplyOnRep((KEntity_Character_Player*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Character_Player::ApplyOnRep((KEntity_Character_Player*)r.Object, r.Index);
				break;
			}
			case 72:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Pickup_Health::ApplyOnRep((KEntity_Pickup_Health*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Pickup_Health::ApplyOnRep((KEntity_Pickup_Health*)r.Object, r.Index);
				break;
			}
			case 35:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Pickup_Weapon_Rocket::ApplyOnRep((KEntity_Pickup_Weapon_Rocket*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Pickup_Weapon_Rocket::ApplyOnRep((KEntity_Pickup_Weapon_Rocket*)r.Object, r.Index);
				break;
			}
			case 24:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Pickup_Weapon_Cannon::ApplyOnRep((KEntity_Pickup_Weapon_Cannon*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Pickup_Weapon_Cannon::ApplyOnRep((KEntity_Pickup_Weapon_Cannon*)r.Object, r.Index);
				break;
			}
			case 163:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun::ApplyOnRep((KEntity_Pickup_Weapon_Shotgun*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Pickup_Weapon_Shotgun::ApplyOnRep((KEntity_Pickup_Weapon_Shotgun*)r.Object, r.Index);
				break;
			}
			case 177:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Pickup_Weapon_Blast::ApplyOnRep((KEntity_Pickup_Weapon_Blast*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Pickup_Weapon_Blast::ApplyOnRep((KEntity_Pickup_Weapon_Blast*)r.Object, r.Index);
				break;
			}
			case 47:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Pickup_Powerup_Brain::ApplyOnRep((KEntity_Pickup_Powerup_Brain*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Pickup_Powerup_Brain::ApplyOnRep((KEntity_Pickup_Powerup_Brain*)r.Object, r.Index);
				break;
			}
			case 76:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Pickup_Powerup_Invis::ApplyOnRep((KEntity_Pickup_Powerup_Invis*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Pickup_Powerup_Invis::ApplyOnRep((KEntity_Pickup_Powerup_Invis*)r.Object, r.Index);
				break;
			}
			case 100:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Powerup_Brain::ApplyOnRep((KEntity_Powerup_Brain*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Powerup_Brain::ApplyOnRep((KEntity_Powerup_Brain*)r.Object, r.Index);
				break;
			}
			case 129:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Powerup_Invis::ApplyOnRep((KEntity_Powerup_Invis*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Powerup_Invis::ApplyOnRep((KEntity_Powerup_Invis*)r.Object, r.Index);
				break;
			}
			case 40:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Projectile_Atom::ApplyOnRep((KEntity_Projectile_Atom*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Projectile_Atom::ApplyOnRep((KEntity_Projectile_Atom*)r.Object, r.Index);
				break;
			}
			case 141:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Projectile_Blast::ApplyOnRep((KEntity_Projectile_Blast*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Projectile_Blast::ApplyOnRep((KEntity_Projectile_Blast*)r.Object, r.Index);
				break;
			}
			case 244:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Projectile_Cannon::ApplyOnRep((KEntity_Projectile_Cannon*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Projectile_Cannon::ApplyOnRep((KEntity_Projectile_Cannon*)r.Object, r.Index);
				break;
			}
			case 255:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Projectile_Rocket::ApplyOnRep((KEntity_Projectile_Rocket*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Projectile_Rocket::ApplyOnRep((KEntity_Projectile_Rocket*)r.Object, r.Index);
				break;
			}
			case 113:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Projectile_ShotgunShard::ApplyOnRep((KEntity_Projectile_ShotgunShard*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Projectile_ShotgunShard::ApplyOnRep((KEntity_Projectile_ShotgunShard*)r.Object, r.Index);
				break;
			}
			case 77:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Projectile_ShotgunBoulder::ApplyOnRep((KEntity_Projectile_ShotgunBoulder*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Projectile_ShotgunBoulder::ApplyOnRep((KEntity_Projectile_ShotgunBoulder*)r.Object, r.Index);
				break;
			}
			case 230:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Weapon_Blast::ApplyOnRep((KEntity_Weapon_Blast*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Weapon_Blast::ApplyOnRep((KEntity_Weapon_Blast*)r.Object, r.Index);
				break;
			}
			case 78:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Weapon_Cannon::ApplyOnRep((KEntity_Weapon_Cannon*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Weapon_Cannon::ApplyOnRep((KEntity_Weapon_Cannon*)r.Object, r.Index);
				break;
			}
			case 88:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Weapon_Rocket::ApplyOnRep((KEntity_Weapon_Rocket*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Weapon_Rocket::ApplyOnRep((KEntity_Weapon_Rocket*)r.Object, r.Index);
				break;
			}
			case 216:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Weapon_Shotgun::ApplyOnRep((KEntity_Weapon_Shotgun*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Weapon_Shotgun::ApplyOnRep((KEntity_Weapon_Shotgun*)r.Object, r.Index);
				break;
			}
			case 98:
			{
				if (destroy)
					KDestroySnapshot_KEntity_Weapon_Zapper::ApplyOnRep((KEntity_Weapon_Zapper*)r.Object, r.Index);
				else
					KSnapshot_KEntity_Weapon_Zapper::ApplyOnRep((KEntity_Weapon_Zapper*)r.Object, r.Index);
				break;
			}
			
		}
	}

	reps.clear();
}

void KSnapshot_KNetPlayer::ApplyOnRep(KNetPlayer* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Character_Monster::ApplyOnRep(KEntity_Character_Monster* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Character_Player::ApplyOnRep(KEntity_Character_Player* obj, u8 index)
{
	switch (index)
	{
		case 17:
		{
			obj->OnRep_ReplicatedWeaponIndex();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Pickup_Health::ApplyOnRep(KEntity_Pickup_Health* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Pickup_Weapon_Rocket::ApplyOnRep(KEntity_Pickup_Weapon_Rocket* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Pickup_Weapon_Cannon::ApplyOnRep(KEntity_Pickup_Weapon_Cannon* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Pickup_Weapon_Shotgun::ApplyOnRep(KEntity_Pickup_Weapon_Shotgun* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Pickup_Weapon_Blast::ApplyOnRep(KEntity_Pickup_Weapon_Blast* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Pickup_Powerup_Brain::ApplyOnRep(KEntity_Pickup_Powerup_Brain* obj, u8 index)
{
	switch (index)
	{
		case 1:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Pickup_Powerup_Invis::ApplyOnRep(KEntity_Pickup_Powerup_Invis* obj, u8 index)
{
	switch (index)
	{
		case 1:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Powerup_Brain::ApplyOnRep(KEntity_Powerup_Brain* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Powerup_Invis::ApplyOnRep(KEntity_Powerup_Invis* obj, u8 index)
{
	switch (index)
	{
		case 3:
		{
			obj->OnRep_bIsInvisible();
			break;
		}
		
	}
}

void KSnapshot_KEntity_Projectile_Atom::ApplyOnRep(KEntity_Projectile_Atom* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Projectile_Blast::ApplyOnRep(KEntity_Projectile_Blast* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Projectile_Cannon::ApplyOnRep(KEntity_Projectile_Cannon* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Projectile_Rocket::ApplyOnRep(KEntity_Projectile_Rocket* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Projectile_ShotgunShard::ApplyOnRep(KEntity_Projectile_ShotgunShard* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Projectile_ShotgunBoulder::ApplyOnRep(KEntity_Projectile_ShotgunBoulder* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Weapon_Blast::ApplyOnRep(KEntity_Weapon_Blast* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Weapon_Cannon::ApplyOnRep(KEntity_Weapon_Cannon* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Weapon_Rocket::ApplyOnRep(KEntity_Weapon_Rocket* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Weapon_Shotgun::ApplyOnRep(KEntity_Weapon_Shotgun* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KSnapshot_KEntity_Weapon_Zapper::ApplyOnRep(KEntity_Weapon_Zapper* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KNetPlayer::ApplyOnRep(KNetPlayer* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Character_Monster::ApplyOnRep(KEntity_Character_Monster* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Character_Player::ApplyOnRep(KEntity_Character_Player* obj, u8 index)
{
	switch (index)
	{
		case 17:
		{
			obj->OnRep_ReplicatedWeaponIndex();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Health::ApplyOnRep(KEntity_Pickup_Health* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Weapon_Rocket::ApplyOnRep(KEntity_Pickup_Weapon_Rocket* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Weapon_Cannon::ApplyOnRep(KEntity_Pickup_Weapon_Cannon* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Weapon_Shotgun::ApplyOnRep(KEntity_Pickup_Weapon_Shotgun* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Weapon_Blast::ApplyOnRep(KEntity_Pickup_Weapon_Blast* obj, u8 index)
{
	switch (index)
	{
		case 7:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Powerup_Brain::ApplyOnRep(KEntity_Pickup_Powerup_Brain* obj, u8 index)
{
	switch (index)
	{
		case 1:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Pickup_Powerup_Invis::ApplyOnRep(KEntity_Pickup_Powerup_Invis* obj, u8 index)
{
	switch (index)
	{
		case 1:
		{
			obj->OnRep_ReppedFlags();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Powerup_Brain::ApplyOnRep(KEntity_Powerup_Brain* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Powerup_Invis::ApplyOnRep(KEntity_Powerup_Invis* obj, u8 index)
{
	switch (index)
	{
		case 3:
		{
			obj->OnRep_bIsInvisible();
			break;
		}
		
	}
}

void KDestroySnapshot_KEntity_Projectile_Atom::ApplyOnRep(KEntity_Projectile_Atom* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Projectile_Blast::ApplyOnRep(KEntity_Projectile_Blast* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Projectile_Cannon::ApplyOnRep(KEntity_Projectile_Cannon* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Projectile_Rocket::ApplyOnRep(KEntity_Projectile_Rocket* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Projectile_ShotgunShard::ApplyOnRep(KEntity_Projectile_ShotgunShard* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Projectile_ShotgunBoulder::ApplyOnRep(KEntity_Projectile_ShotgunBoulder* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Blast::ApplyOnRep(KEntity_Weapon_Blast* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Cannon::ApplyOnRep(KEntity_Weapon_Cannon* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Rocket::ApplyOnRep(KEntity_Weapon_Rocket* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Shotgun::ApplyOnRep(KEntity_Weapon_Shotgun* obj, u8 index)
{
	switch (index)
	{
		
	}
}

void KDestroySnapshot_KEntity_Weapon_Zapper::ApplyOnRep(KEntity_Weapon_Zapper* obj, u8 index)
{
	switch (index)
	{
		
	}
}



#endif