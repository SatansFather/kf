// generated by net_code_gen.py based on net_format.txt

#if !_COMPILER
#include "snapshot.h"
#include "client.h"
#include "state.h"
@#include "$HEADER"
@
THashMap<std::type_index, u8> ClassIDs =
{
	@{ typeid($CLASSNAME), $CLASSID },
	@
};

u8 KSnapshot::GetPlayerClassID()
{
	return %PLAYERID%;
}

struct KPendingOnRep
{
	KSnapshottable* Object = nullptr;
	u8 Index;
};

TVector<KPendingOnRep> PendingOnReps;
TVector<KPendingOnRep> DestroyPendingOnReps;

u8 KSnapshot::LookUpClassID(std::type_index ind)
{
	return ClassIDs[ind];
}

KString KSnapshot::NameFromClassID(u8 id)
{
	switch (id)
	{
		@case $CLASSID: return "$CLASSNAME";
		@
	}
	return "";
}

@struct KSnapshot_$CLASSNAME : public KSnapshot
{
	`$PROPTYPE $PROPNAME$IFPROPDEFAULT = $PROPDEFAULT$ENDIF;
	`
	u32 MemberCount() override;
	void GetAddressAndSize(u8 propIndex, u8*& addr, u8& size) override;
	bool ClientNeedsProperty(u8 propIndex, u8 playerIndex, class KSnapshottable* object, u32 lastAcked, bool storingReplay) override;
	u32 GetClassTypeSize() override;
	void PackObject(class KSnapshottable* obj) override;
	static u32 ApplyPropertyToObject(u8 index, $CLASSNAME* object, const u8* data);
	static void ApplyOnRep($CLASSNAME* obj, u8 index);
};

@@#pragma pack(push, 1)
struct KDestroySnapshot_$CLASSNAME : public KDestroySnapshot
{
	`$IFPROPDESTROY$PROPTYPE $PROPNAME$PROPEQDEF;$LINEBREAK	$ENDIF`
	$DESTROY_REPCOUNT
	void ApplyDestroyToObject($CLASSNAME* obj);
	static void ApplyOnRep($CLASSNAME* obj, u8 index);
};
#pragma pack(pop)

@UPtr<KDestroySnapshot> KDestroySnapshot::FillDestroy(KSnapshottable* obj)
{
	switch (obj->ClassID)
	{
		@case $CLASSID:
		{
			$CLASSNAME* casted = ($CLASSNAME*)obj;
			UPtr<KDestroySnapshot_$CLASSNAME> snap = std::make_unique<KDestroySnapshot_$CLASSNAME>();
			snap->ClassID = obj->GetClassID();
			snap->NetID = obj->GetNetID();
			`$IFPROPDESTROY{
				u8* snapAddr = (u8*)&snap->$PROPNAME;
				u8 size = sizeof($PROPTYPE);
				$PACKPROP	
			}$ENDIF`
			return snap;
		}
		@
	}	
	return nullptr;
}

u32 KDestroySnapshot::GetSize(u8 classID)
{
	switch (classID)
	{
		@case ($CLASSID): return sizeof(KDestroySnapshot_$CLASSNAME) - $DESTROY_CHECKREPCOUNT;
		@
	}

	return 0;
}

void KDestroySnapshot::Apply(KSnapshottable* obj, u8* destroyData)
{
	switch (obj->ClassID)
	{
		@case $CLASSID:
		{
			KDestroySnapshot_$CLASSNAME* ptr = (KDestroySnapshot_$CLASSNAME*)destroyData;
			ptr->ApplyDestroyToObject(dynamic_cast<$CLASSNAME*>(obj));
			break;
		}
		@
	}
}


@void KDestroySnapshot_$CLASSNAME::ApplyDestroyToObject($CLASSNAME* obj)
{
	`$IFPROPDESTROY{
		$APPLYPROP
		$DESTROY_ADDONREP
	}$ENDIF`
}

@

@THashMap<u32, KSnapshot_$CLASSNAME[MAX_SNAPSHOTS]> SnapshotHistory_$CLASSNAME;
@

@void KSnapshot_$CLASSNAME::PackObject(class KSnapshottable* obj)
{
	$CLASSNAME* casted = ($CLASSNAME*)obj;
	`{
		u8* snapAddr = nullptr;
		u8 size = 0;
		GetAddressAndSize($PROPINDEX, snapAddr, size);
		$PACKPROP
	}
	`
}

@
KSnapshot* KSnapshot::GetDefaultSnapshot(u8 classID)
{
	static TVector<UPtr<KSnapshot>> defaults;
	if (defaults.size() == 0)
	{
		defaults.resize(256);
		@defaults[$CLASSID] = std::make_unique<KSnapshot_$CLASSNAME>();
		@
	}
	return defaults[classID].get();
}

KSnapshot* KSnapshot::GetHistoryForObject(u8 classID, u32 netID)
{
	switch (classID)
	{
		@case $CLASSID:
		{
			return (KSnapshot*)&(SnapshotHistory_$CLASSNAME[netID]);
		}
		@
	}
	return nullptr;
}

KSnapshot* KSnapshot::GetHistoryAtFrame(u32 frame)
{
	if (frame == 0 || KTime::FrameCount() - frame >= MAX_SNAPSHOTS)
		return nullptr;

	return (KSnapshot*)((char*)this + GetClassTypeSize() * (frame % MAX_SNAPSHOTS));
}


void KSnapshot::RemoveObjectFromHistory(u8 classID, u32 netID)
{
	switch (classID)
	{
		@case $CLASSID: SnapshotHistory_$CLASSNAME.erase(netID);
		@
	}
}

KSnapshottable* KSnapshot::CreateReplicatedObject(u32 classID, u32 netID)
{
	KSnapshottable* out = nullptr;

	switch (classID)
	{
		case %PLAYERID%:
		{
			KNetPlayer* player = new KNetPlayer;
#if !_SERVER
			u32 index = netID & 0x000000FF;
			KNetInterface_Client* c = dynamic_cast<KNetInterface_Client*>(GetNetInterface());
			c->ConnectedPlayers[index] = player;
			player->ClassID = %PLAYERID%;
#endif
			out = player;
			break;
		}
		@$PLAYERCLASScase $CLASSID:
		{
			out = TDataPool<$CLASSNAME>::GetPool()->CreateNew().Get();
			out->ClassID = $CLASSID;
			break;
		}
		@
	}

	if (out)
	{
		out->NetID = netID;
		out->SnapshottableFrameCreated = KTime::FrameCount();
		out->bCreatedFromServer = true;
		if (classID != %PLAYERID%) 
			GetNetState()->AddReplicatedObject(out);
	}

	return out;
}

@u32 KSnapshot_$CLASSNAME::MemberCount() { return $PROPCOUNT; }
@

@u32 KSnapshot_$CLASSNAME::GetClassTypeSize() { return sizeof(KSnapshot_$CLASSNAME); }
@

@void KSnapshot_$CLASSNAME::GetAddressAndSize(u8 propIndex, u8*& addr, u8& size)
{
	switch(propIndex)
	{
		`case $PROPINDEX:
			addr = (u8*)&$PROPNAME;
			size = sizeof($PROPTYPE);
			break;
		`
	}
}
@

@
bool KSnapshot_$CLASSNAME::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked, bool storingReplay)
{
	switch (propIndex)
	{
		`case $PROPINDEX: return $PROPCONDITION;
		`
	}
	return false;
}
@

u32 KSnapshot::Apply(u8 index, KSnapshottable* object, const u8* data)
{
	switch (object->ClassID)
	{
		@case $CLASSID:
		{
			$CLASSNAME* casted = ($CLASSNAME*)object;
			return KSnapshot_$CLASSNAME::ApplyPropertyToObject(index, casted, data);
			break;
		}
		@
	}

	return 0;
}

@u32 KSnapshot_$CLASSNAME::ApplyPropertyToObject(u8 index, $CLASSNAME* object, const u8* data)
{
	switch (index)
	{
		`
		case $PROPINDEX:
		{
			$IFPROPTRANS$PROPTYPE prop;
			memcpy(&prop, data, sizeof($PROPTYPE));
			object->SetTransient_$PROPNAME(prop);$ENDIF$COPYPROP
			$ADDONREP
			return sizeof($PROPTYPE);
		}`
	}

	return 0;
}

@

void KSnapshot::ApplyOnReps(bool destroy)
{
	TVector<KPendingOnRep>& reps = destroy ? DestroyPendingOnReps : PendingOnReps;

	for (KPendingOnRep& r : reps)
	{
		switch (r.Object->ClassID)
		{
			@case $CLASSID:
			{
				if (destroy)
					KDestroySnapshot_$CLASSNAME::ApplyOnRep(($CLASSNAME*)r.Object, r.Index);
				else
					KSnapshot_$CLASSNAME::ApplyOnRep(($CLASSNAME*)r.Object, r.Index);
				break;
			}
			@
		}
	}

	reps.clear();
}

@void KSnapshot_$CLASSNAME::ApplyOnRep($CLASSNAME* obj, u8 index)
{
	switch (index)
	{
		`$IFONREPcase $PROPINDEX:
		{
			obj->OnRep_$ONREP();
			break;
		}
		$ENDIF`
	}
}

@@void KDestroySnapshot_$CLASSNAME::ApplyOnRep($CLASSNAME* obj, u8 index)
{
	switch (index)
	{
		`$IFONREPcase $PROPINDEX:
		{
			obj->OnRep_$ONREP();
			break;
		}
		$ENDIF`
	}
}

@

#endif