import os

class ClassInfo:
	ClassName = ""
	HeaderPath = ""
	Hash = 0

	class Property:
		Type = ""
		Name = ""
		Condition = ""
		ConditionFunction = ""
		FirstOnly = False

	Properties = []

	def __init__(self):
		self.ParentName = ""
		self.ClassName = ""
		self.DestroyName = ""
		self.HeaderPath = ""
		self.Hash = 0
		self.Properties = []

	# class ID is just the sum of the string name bytes
	# always ensure there are no collisions before compiling cpp
	def HashName(self):
		byteName = str.encode(self.ClassName)
		for char in byteName:
			self.Hash = self.Hash + char
		self.Hash = self.Hash % 256

classIDs = []
potentialHeaders = ["src/engine/net/player.h"]


# TODO switching to unreal style replication where class memebers have the macro 
# warn hash matches, come up with a solution if it ever happens lol
# MemberCount(), GetAddressAndSize() and other snapshot functions should be on KSnapshottable directly now

# iterate entity headers to find snapshottables
for currentDir, subDirs, files in os.walk("src/game/entity"):
	for file in files:
		if (file.endswith(".h")):
			potentialHeaders.append(currentDir.replace('\\', '/') + '/' + file)

for header in potentialHeaders:
	with open (header, 'r') as file:
		memberIndex = 0
		insideStruct = False
		hasClassID = False
		idEntry = ClassInfo()
		for line in file:
			stripped = line.strip()

			# search for a net snapshot struct
			if stripped.startswith("struct KNetSnapshot_"):			
				insideStruct = True

				classNames = stripped.split('_', 1)[1].split(' :')

				idEntry.ClassName = classNames[0]

				print(idEntry.ClassName)

				# see if we have parent
				if '_' in classNames[1]:
					idEntry.ParentName = classNames[1].split('_')[1]
				
				idEntry.HeaderPath = header.split("src/")[1]
				idEntry.HashName()
				classIDs.append(idEntry)
				hasClassID = True
				continue

			if insideStruct:
				if (stripped.startswith("SNAPSHOT_PROPERTY")):
					listed = stripped.split("SHOT_PROPERTY(")[1]
					listed = listed.split(");")[0].strip()
					listed = listed.split(',')
					
					prop = ClassInfo.Property()

					prop.Type = listed[0].strip()
					prop.Name = listed[1].strip()
					if (prop.Name.endswith(')')):
						prop.Name = prop.Name.rstrip(prop.Name[-1])

					if '=' in prop.Name:
						prop.Name = prop.Name.split('=')[0].strip()
						
					prop.Condition = ""
					if (len(listed) >= 3):
						for i in range(2, len(listed)):
							if listed[i].strip().startswith("SNAP_FIRST_ONLY"):
								prop.FirstOnly = True
							else:
								prop.Condition = listed[i].strip()
						

						if (prop.Condition.startswith("SNAP_SEND_CONDITION")):
							prop.ConditionFunction = prop.Condition.split('(')[1].split(')')[0].strip()
							prop.Condition = "SNAP_SEND_CONDITION"
							
						if (prop.Condition.endswith(')')):
							prop.Condition = prop.Condition.rstrip(prop.Condition[-1])

					idEntry.Properties.append(prop)

			# search for TSnapshottable template, check for destroy type
			if hasClassID and "TSnapshottable<" in line:
				destroyIndex = line.find(', KDestroyedNetObject')
				if destroyIndex != -1:
					templateEnd = line.find('>')
					idEntry.DestroyName = line[destroyIndex : templateEnd]
					




# create class_id file

fileText = """// generated by net_code_gen.py

#if !_COMPILER

#include "class_id.h"
#include "snapshot.h"

"""

for classID in classIDs:
	fileText += "#include \"" + classID.HeaderPath + "\"\n"

fileText += "\nvoid InitNetClassIDs()\n{\n"

for classID in classIDs:
	fileText += "\tTSnapshottable<KNetSnapshot_" + classID.ClassName + classID.DestroyName +">::Default.ClassID = " + str(classID.Hash) + ";\n"


fileText += "}\n\nKString NameFromClassID(u8 id)\n{\n\tswitch (id)\n\t{"

for classID in classIDs:
	fileText += "\n\t\tcase " + str(classID.Hash) + ": " + "return \"" + classID.ClassName + "\";"

fileText += "\n\t}\n\treturn \"\";\n"

fileText += "}\n\n#endif"

with open ("src/engine/net/class_id.cpp", 'w') as file:
	file.write(fileText)


# create snapshot_defs file

fileText = "// generated by net_code_gen.py\n\n#if !_COMPILER\n\n#include \"state.h\"\n#include \"engine/game/local_player.h\"\n"

classDefs = ""

createObjects = """
KSnapshottable* CreateReplicatedObject(u32 classID, u32 netID)
{
	KSnapshottable* out = nullptr;

	switch (classID)
	{
"""

for classID in classIDs:
	fileText += "#include \"" + classID.HeaderPath + "\"\n"

	classDefs += "u8 KNetSnapshot_" + classID.ClassName + "::MemberCount() { return " + str(len(classID.Properties)) + "; }\n\n"

	classDefs += "void KNetSnapshot_" + classID.ClassName + "::GetAddressAndSize(u8 index, u8*& addr, u8& size)\n{\n\tswitch (index)\n\t{\n"
	memberIndex = 0
	for prop in classID.Properties:
		classDefs += "\t\tcase " + str(memberIndex) + ":\n\t\t\taddr = (u8*)&" + prop.Name + ";\n\t\t\tsize = sizeof(" + prop.Type + ");\n\t\t\tbreak;\n"
		memberIndex += 1
	classDefs += "\t}\n}\n\n"
	
	classDefs += "bool KNetSnapshot_" + classID.ClassName + "::PropertyIsFirstOnly(u8 index)\n{\n\tswitch (index)\n\t{\n"
	
	memberIndex = 0
	for prop in classID.Properties:
		classDefs += "\t\tcase " + str(memberIndex) + ": return " + str(prop.FirstOnly).lower() + ";\n"
		memberIndex += 1

	classDefs += "\t}\n\treturn false;\n}\n\n"

	firstCheck = "(lastAcked < object->SnapshottableFrameCreated)"

	classDefs += "bool KNetSnapshot_" + classID.ClassName + "::ClientNeedsProperty(u8 propIndex, u8 playerIndex, KSnapshottable* object, u32 lastAcked)\n{\n\tswitch (propIndex)\n\t{\n"
	memberIndex = 0
	for prop in classID.Properties:
		classDefs += "\t\tcase " + str(memberIndex) + ": return "
		if prop.Condition == "":
			if prop.FirstOnly:
				classDefs += firstCheck + ";\n"
			else:
				classDefs += "true;\n"
		elif prop.Condition == "SNAP_SEND_OWNER":
			if prop.FirstOnly:
				classDefs += firstCheck + " && "
			classDefs += "playerIndex == object->OwningPlayerIndex;\n"
		elif prop.Condition == "SNAP_SEND_OTHERS":
			if prop.FirstOnly:
				classDefs += firstCheck + " && "
			classDefs += "playerIndex != object->OwningPlayerIndex;\n"
		elif prop.Condition == "SNAP_SEND_CONDITION":
			if prop.FirstOnly:
				classDefs += firstCheck + " && "
			classDefs += prop.ConditionFunction + "(playerIndex, object);\n"
		memberIndex += 1
	classDefs += "\t}\n\treturn false;\n}\n\n"

	createObjects += "\t\tcase " + str(classID.Hash) + ":\n\t\t\tout = TSnapshottable<KNetSnapshot_" + classID.ClassName + classID.DestroyName + ">::InstantiateObject();\n\t\t\tbreak;\n"

createObjects += """		default: 
			K_ASSERT(false, "no valid class ID given to spawn net object");
			break;
	}

	if (out)
	{
		out->NetID = netID;
		out->SnapshottableFrameCreated = KTime::FrameCount();
		GetNetState()->AddReplicatedObject(out);
	}

	return out;
}
"""

fileText += "\n" + createObjects

fileText += "\n" + classDefs

fileText += "#endif"

with open ("src/engine/net/snapshot_defs.cpp", 'w') as file:
	file.write(fileText)

print("finished")